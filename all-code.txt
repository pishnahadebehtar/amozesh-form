PROJECT CODE COLLECTION
==================================================

FILE: collect-code.js
----------------------------------------
import fs from "fs";
import path from "path";

const OUTPUT_FILE = "all-code.txt";
const IGNORE_DIRS = ["node_modules", ".next", "dist", "build", ".git"];

const allowedExtensions = [
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".css",
  ".scss",
  ".json",
  ".md",
  ".txt",
  ".yml",
  ".yaml",
  ".config.js",
];

function shouldIncludeFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return allowedExtensions.includes(ext);
}

function collectFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      if (!IGNORE_DIRS.includes(file)) {
        fileList = collectFiles(filePath, fileList);
      }
    } else {
      if (shouldIncludeFile(filePath)) {
        fileList.push(filePath);
      }
    }
  });

  return fileList;
}

function readAndFormatFiles(fileList) {
  let output = "PROJECT CODE COLLECTION\n";
  output += "=".repeat(50) + "\n\n";

  fileList.forEach((filePath) => {
    try {
      const content = fs.readFileSync(filePath, "utf8");
      output += `FILE: ${filePath}\n`;
      output += "-".repeat(40) + "\n";
      output += content;
      output += "\n\n" + "=".repeat(50) + "\n\n";
    } catch (error) {
      console.log(`Error reading ${filePath}:`, error.message);
    }
  });

  return output;
}

// Main execution
console.log("Collecting project files...");
const allFiles = collectFiles(".");
console.log(`Found ${allFiles.length} files`);

const formattedContent = readAndFormatFiles(allFiles);

fs.writeFileSync(OUTPUT_FILE, formattedContent, "utf8");
console.log(`All code has been saved to ${OUTPUT_FILE}`);


==================================================

FILE: eslint.config.js
----------------------------------------
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])



FILE: package.json
----------------------------------------
{
  "name": "form-builder-react",
  "private": true,
  "version": "0.0.0",
  "homepage": "https://pishnahadebehtar.github.io/mother-of-all-forms",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "predeploy": "npm run build",
    "deploy": "gh-pages -d dist"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@hookform/resolvers": "^5.2.2",
    "@mui/icons-material": "^7.3.5",
    "@mui/lab": "^7.0.1-beta.19",
    "@mui/material": "^7.3.5",
    "@mui/x-data-grid": "^8.19.0",
    "@mui/x-date-pickers": "^8.19.0",
    "appwrite": "^21.4.0",
    "date-fns": "^4.1.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.66.1",
    "react-markdown": "^10.1.0",
    "react-router-dom": "^7.9.6",
    "react-window": "^2.2.3",
    "stylis": "^4.3.6",
    "stylis-plugin-rtl": "^2.1.1",
    "uuid": "^13.0.0",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@types/stylis": "^4.2.7",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "gh-pages": "^6.3.0",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


==================================================

FILE: README.md
----------------------------------------
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```


==================================================

FILE: src\App.css
----------------------------------------
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


==================================================

FILE: src\App.tsx
----------------------------------------
import React from "react";
import { HashRouter as Router, Routes, Route } from "react-router-dom";
import ThemeProviders from "./components/ThemeProviders";
import Home from "./pages/Home";
import AboutPage from "./pages/About";
import Layout from "./components/Layout"; // Import Layout

function App() {
  return (
    <div dir="rtl">
      <ThemeProviders>
        <Router>
          <Routes>
            {/* Wrap everything in Layout */}
            <Route element={<Layout />}>
              <Route path="/" element={<Home />} />
              <Route path="/about" element={<AboutPage />} />
            </Route>
          </Routes>
        </Router>
      </ThemeProviders>
    </div>
  );
}

export default App;


==================================================

FILE: src\components\ActionButtons.tsx
----------------------------------------
import React from "react";
import { Button, Box } from "@mui/material";

interface ActionButtonsProps {
  onFormTypes: () => void;
  onCreateRecord: () => void;
  onList: () => void;
}

const ActionButtons: React.FC<ActionButtonsProps> = ({
  onFormTypes,
  onCreateRecord,
  onList,
}) => {
  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: { xs: "column", sm: "row" }, // Column on mobile
        justifyContent: "center",
        alignItems: "center",
        mb: 4,
        p: 2,
        gap: 3, // Smaller gap on mobile
        width: "100%",
        maxWidth: "100%", // Force full width matching InputSection
        boxSizing: "border-box",
      }}
    >
      {[
        { label: "مدیریت انواع فرم", onClick: onFormTypes },
        { label: "ایجاد رکورد", onClick: onCreateRecord },
        { label: "مشاهده لیست", onClick: onList },
      ].map((btn, index) => (
        <Button
          key={index}
          variant="contained"
          onClick={btn.onClick}
          sx={{
            borderRadius: 50,
            fontWeight: 700,
            textTransform: "none",
            px: 3,
            py: 1.5,
            width: { xs: "100%", sm: "auto" }, // Full width on mobile
            // Force visibility colors
            backgroundColor: "#FFC400 !important",
            color: "#000000 !important",
            filter: "brightness(100%) contrast(100%)",
            isolation: "isolate",
            "&:hover": {
              backgroundColor: "#E6B800 !important",
            },
          }}
        >
          {btn.label}
        </Button>
      ))}
    </Box>
  );
};

export default ActionButtons;


==================================================

FILE: src\components\animatedEye\AnimatedEye.tsx
----------------------------------------
import React, { useRef, useState, useCallback, useEffect } from "react";
import {
  Box,
  Typography,
  useMediaQuery,
  useTheme,
  CircularProgress,
  Fade,
} from "@mui/material";
import { AnimatedEyeProps } from "./types";
import { EyeVisual } from "./components/EyeVisual";
import { InputSection } from "./components/InputSection";
import ChatHistory, { type ChatMessage } from "./components/ChatHistory";
import { getChatMessages } from "@/lib/appwrite";
import { useBlink } from "./hooks/useBlink";
import { usePupilMovement } from "./hooks/usePupilMovement";
import { useInputFocus } from "./hooks/useInputFocus";
import { generateRandomPupilPosition } from "./utils/positionUtils";
import AudioVisualizer from "./components/AudioVisualizer";

// Import assets
import soundFile from "@/assets/sound.mp3";
import skyImg from "@/assets/sky.jpg";
import infernoImg from "@/assets/inferno.jpg";

interface ExtendedProps extends AnimatedEyeProps {
  showSnackbar?: (
    msg: string,
    severity?: "success" | "error" | "info" | "warning"
  ) => void;
  onChatRefresh?: () => void;
  loading?: boolean;
  onAngryStateChange?: (isAngry: boolean) => void;
}

export default function AnimatedEyes({
  size = 180,
  showSnackbar,
  onChatRefresh,
  loading = false,
  onAngryStateChange,
}: ExtendedProps) {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));

  // --- REFS ---
  const eyeRef1 = useRef<HTMLDivElement | null>(null);
  const eyeRef2 = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<HTMLInputElement | null>(null);
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const audioObjRef = useRef<HTMLAudioElement | null>(null);

  const idleMoveInterval = useRef<NodeJS.Timeout | null>(null);
  const idleBlinkInterval = useRef<NodeJS.Timeout | null>(null);
  const idleStartTimeout = useRef<NodeJS.Timeout | null>(null);
  const mouseOutRef = useRef<boolean>(false);
  const sequenceTimeouts = useRef<NodeJS.Timeout[]>([]);

  // --- STATE ---
  const [isFocused, setIsFocused] = useState(false);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [chatVisible, setChatVisible] = useState(false);

  // Fixed: Use state for rendering the visualizer prop
  const [activeAudio, setActiveAudio] = useState<HTMLAudioElement | null>(null);

  // Asset State
  const [skyBlobUrl, setSkyBlobUrl] = useState<string | undefined>(undefined);
  const [infernoBlobUrl, setInfernoBlobUrl] = useState<string | undefined>(
    undefined
  );
  const [assetsLoaded, setAssetsLoaded] = useState(false);

  const [clickCount, setClickCount] = useState(0);
  const [isAngry, setIsAngry] = useState(false);
  const [isTightSquint, setIsTightSquint] = useState(false);
  const [isResetting, setIsResetting] = useState(false);
  const [showSky, setShowSky] = useState(false);
  const [showInferno, setShowInferno] = useState(false);
  const [glintState, setGlintState] = useState<"normal" | "flash" | "growing">(
    "normal"
  );

  // Notify parent
  useEffect(() => {
    if (onAngryStateChange) {
      onAngryStateChange(isAngry);
    }
  }, [isAngry, onAngryStateChange]);

  // --- ROBUST ASSET PRELOADING ---
  useEffect(() => {
    let isMounted = true;
    const loadAssets = async () => {
      try {
        // 1. Load Audio
        const audioResponse = await fetch(soundFile);
        const audioBlob = await audioResponse.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        const audio = new Audio(audioUrl);
        audio.preload = "auto";
        audio.load();

        // Store in ref for imperative logic
        audioObjRef.current = audio;

        // 2. Load Images
        const skyRes = await fetch(skyImg);
        const skyBlob = await skyRes.blob();
        const skyUrl = URL.createObjectURL(skyBlob);

        const infernoRes = await fetch(infernoImg);
        const infernoBlob = await infernoRes.blob();
        const infernoUrl = URL.createObjectURL(infernoBlob);

        if (isMounted) {
          setSkyBlobUrl(skyUrl);
          setInfernoBlobUrl(infernoUrl);
          // Fixed: Set the state for the visualizer once, and keep it.
          setActiveAudio(audio);
          setAssetsLoaded(true);
        }
      } catch (err) {
        console.error("Failed to preload assets:", err);
        // Fallback
        if (isMounted) {
          const audio = new Audio(soundFile);
          audioObjRef.current = audio;
          setActiveAudio(audio); // Fallback state set
          setSkyBlobUrl(skyImg);
          setInfernoBlobUrl(infernoImg);
          setAssetsLoaded(true);
        }
      }
    };

    loadAssets();

    return () => {
      isMounted = false;
      if (audioObjRef.current) {
        audioObjRef.current.pause();
      }
    };
  }, []);

  // --- HOOKS ---
  const {
    topTransform,
    bottomTransform,
    performBlink,
    doubleBlink,
    openEyes,
    squintEyes,
  } = useBlink();
  const {
    pupilRef: pupilRef1,
    updatePupilPosition: updatePupilPosition1,
    handleMouseMove: handleMouseMove1,
    setPupilOffset: setPupilOffset1,
  } = usePupilMovement({ size, eyeRef: eyeRef1, isFocused });
  const {
    pupilRef: pupilRef2,
    updatePupilPosition: updatePupilPosition2,
    handleMouseMove: handleMouseMove2,
    setPupilOffset: setPupilOffset2,
  } = usePupilMovement({ size, eyeRef: eyeRef2, isFocused });
  const { inputValue, handleInput, updatePupilToInput } = useInputFocus({
    updatePupilPosition: (x: number, y: number) => {
      if (isAngry || isResetting) return;
      updatePupilPosition1(x, y);
      if (!isMobile) updatePupilPosition2(x, y);
    },
    inputRef,
    canvasRef,
    isFocused,
  });

  // --- HELPERS ---
  const stopIdleBehavior = useCallback(() => {
    if (idleStartTimeout.current) clearTimeout(idleStartTimeout.current);
    if (idleMoveInterval.current) clearInterval(idleMoveInterval.current);
    if (idleBlinkInterval.current) clearInterval(idleBlinkInterval.current);
  }, []);

  const startIdleBehavior = useCallback(() => {
    setPupilOffset1(0, 0, "0.5s");
    if (!isMobile) setPupilOffset2(0, 0, "0.5s");
    stopIdleBehavior();
    idleBlinkInterval.current = setInterval(() => doubleBlink(), 2000);
    idleStartTimeout.current = setTimeout(() => {
      if (!mouseOutRef.current) return;
      const move = () => {
        const { x, y } = generateRandomPupilPosition(size);
        setPupilOffset1(x, y, "2s");
        if (!isMobile) setPupilOffset2(x, y, "2s");
      };
      move();
      idleMoveInterval.current = setInterval(move, 2500);
    }, 500);
  }, [
    doubleBlink,
    isMobile,
    setPupilOffset1,
    setPupilOffset2,
    size,
    stopIdleBehavior,
  ]);

  const resetNormalState = useCallback(() => {
    setIsResetting(true);
    setIsAngry(false);
    setIsTightSquint(false);
    setShowSky(false);
    setShowInferno(false);
    setGlintState("normal");
    setClickCount(0);

    if (audioObjRef.current) {
      audioObjRef.current.pause();
      audioObjRef.current.currentTime = 0;
    }

    // Fixed: Do NOT clear activeAudio state here.
    // We keep the connection alive for the next time.

    sequenceTimeouts.current.forEach((t) => clearTimeout(t));
    sequenceTimeouts.current = [];
    openEyes();

    setTimeout(() => {
      setIsResetting(false);
      if (mouseOutRef.current) startIdleBehavior();
      else stopIdleBehavior();
    }, 5000);
  }, [startIdleBehavior, stopIdleBehavior, openEyes]);

  const startAngrySequence = useCallback(() => {
    const audio = audioObjRef.current;

    if (!audio || audio.readyState < 3) {
      // Fallback: try to play anyway if readyState is flaky on some mobile browsers
      if (!audio) {
        showSnackbar?.("فایل صوتی هنوز آماده نیست...", "warning");
        return;
      }
    }

    setIsAngry(true);
    setClickCount(0);
    stopIdleBehavior();

    audio.currentTime = 0;
    audio.volume = 1.0;

    const playPromise = audio.play();
    if (playPromise !== undefined) {
      playPromise.catch((e) => {
        if (e.name !== "AbortError") console.error("Audio play failed:", e);
      });
    }

    setPupilOffset1(0, 0, "0.5s");
    if (!isMobile) setPupilOffset2(0, 0, "0.5s");

    sequenceTimeouts.current.push(
      setTimeout(() => setGlintState("flash"), 2000),
      setTimeout(() => setGlintState("normal"), 2300),
      setTimeout(() => setGlintState("growing"), 3000),
      setTimeout(() => setShowSky(true), 7000),
      setTimeout(() => setShowSky(false), 11000),
      setTimeout(() => setShowInferno(true), 13000),
      setTimeout(() => setShowInferno(false), 20000),
      setTimeout(() => setIsTightSquint(true), 23700),
      setTimeout(() => {
        if (audio) {
          const fadeInterval = setInterval(() => {
            if (audio.volume > 0.05) audio.volume -= 0.05;
            else {
              audio.volume = 0;
              audio.pause();
              clearInterval(fadeInterval);
            }
          }, 100);
        }
      }, 28000),
      setTimeout(() => resetNormalState(), 31000)
    );
  }, [
    stopIdleBehavior,
    resetNormalState,
    isMobile,
    setPupilOffset1,
    setPupilOffset2,
    showSnackbar,
  ]);

  const handleEyeClick = useCallback(() => {
    if (isAngry || isResetting) return;

    const newCount = clickCount + 1;
    setClickCount(newCount);

    if (newCount < 3) {
      performBlink();
    } else {
      // Allow starting if loaded OR if we have the ref (readyState check inside startAngrySequence handles details)
      if (assetsLoaded && audioObjRef.current) {
        startAngrySequence();
      } else {
        showSnackbar?.("در حال آماده‌سازی صدا...", "info");
        setClickCount(2);
      }
    }
  }, [
    clickCount,
    isAngry,
    isResetting,
    performBlink,
    startAngrySequence,
    assetsLoaded,
    showSnackbar,
  ]);

  // Mouse Events
  const onMouseMove = useCallback(
    (event: MouseEvent) => {
      if (isAngry || isResetting) return;
      if (mouseOutRef.current) {
        mouseOutRef.current = false;
        stopIdleBehavior();
      }
      handleMouseMove1(event);
      if (!isMobile) handleMouseMove2(event);
    },
    [
      handleMouseMove1,
      handleMouseMove2,
      isMobile,
      stopIdleBehavior,
      isAngry,
      isResetting,
    ]
  );

  const onMouseLeave = useCallback(() => {
    if (isFocused || isAngry || isResetting) return;
    mouseOutRef.current = true;
    startIdleBehavior();
  }, [isFocused, startIdleBehavior, isAngry, isResetting]);

  const onMouseEnter = useCallback(() => {
    mouseOutRef.current = false;
    if (!isAngry && !isResetting) stopIdleBehavior();
  }, [stopIdleBehavior, isAngry, isResetting]);

  const onVisibilityChange = useCallback(() => {
    if (document.visibilityState === "hidden") onMouseLeave();
    else onMouseEnter();
  }, [onMouseEnter, onMouseLeave]);

  useEffect(() => {
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseleave", onMouseLeave);
    document.addEventListener("mouseenter", onMouseEnter);
    document.addEventListener("visibilitychange", onVisibilityChange);
    return () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseleave", onMouseLeave);
      document.removeEventListener("mouseenter", onMouseEnter);
      document.removeEventListener("visibilitychange", onVisibilityChange);
      stopIdleBehavior();
    };
  }, [
    onMouseMove,
    onMouseLeave,
    onMouseEnter,
    onVisibilityChange,
    stopIdleBehavior,
  ]);

  const getEyelidTransforms = () => {
    if (isTightSquint)
      return { top: "translateY(-30%)", bottom: "translateY(50%)" };
    if (isAngry) return { top: "translateY(-30%)", bottom: "translateY(70%)" };
    return { top: topTransform, bottom: bottomTransform };
  };

  const { top: currentTop, bottom: currentBottom } = getEyelidTransforms();
  const getEyeGap = () => (isMobile ? 0 : 6);

  const handleFocus = useCallback(() => {
    if (isAngry || isResetting) return;
    setIsFocused(true);
    stopIdleBehavior();
    squintEyes();
    setTimeout(updatePupilToInput, 0);
  }, [squintEyes, stopIdleBehavior, updatePupilToInput, isAngry, isResetting]);

  const handleBlur = useCallback(() => {
    setIsFocused(false);
    openEyes();
  }, [openEyes]);

  useEffect(() => {
    const input = inputRef.current;
    if (input) {
      input.addEventListener("focus", handleFocus);
      input.addEventListener("blur", handleBlur);
    }
    return () => {
      if (input) {
        input.removeEventListener("focus", handleFocus);
        input.removeEventListener("blur", handleBlur);
      }
    };
  }, [handleFocus, handleBlur]);

  const handleNewMessage = useCallback(
    (newMsg: ChatMessage) => {
      setMessages((prev) => {
        const updated = [...prev, newMsg];
        if (updated.length > 0) setChatVisible(true);
        return updated;
      });
      if (newMsg.role === "assistant" && onChatRefresh) onChatRefresh();
    },
    [onChatRefresh]
  );

  const loadHistory = useCallback(async () => {
    try {
      const typedHistory = await getChatMessages();
      setMessages(typedHistory);
      if (typedHistory.length > 0) setChatVisible(true);
    } catch {
      showSnackbar?.("خطا در بارگذاری چت", "error");
    }
  }, [showSnackbar]);

  useEffect(() => {
    const init = async () => await loadHistory();
    init();
  }, [loadHistory]);

  const handleClick = useCallback(() => performBlink(), [performBlink]);

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        justifyContent: "flex-start",
        alignItems: "center",
        minHeight: "70vh",
        backgroundColor: "black",
        p: 2,
        gap: 2,
        direction: "rtl",
        position: "relative",
      }}
      dir="rtl"
    >
      {loading && (
        <Box
          sx={{
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "rgba(0,0,0,0.5)",
            zIndex: 10,
          }}
        >
          <CircularProgress size={60} sx={{ color: "white" }} />
        </Box>
      )}

      <Box
        sx={{
          display: "flex",
          gap: getEyeGap(),
          justifyContent: "center",
          alignItems: "center",
          flexWrap: "wrap",
        }}
      >
        <EyeVisual
          size={size}
          eyeRef={eyeRef1}
          pupilRef={pupilRef1}
          topTransform={currentTop}
          bottomTransform={currentBottom}
          isAngry={isAngry}
          isResetting={isResetting}
          showSky={showSky}
          showInferno={showInferno}
          glintState={glintState}
          onClick={handleEyeClick}
          isLeft={true}
          isMobile={isMobile}
          skyImageSrc={skyBlobUrl}
          infernoImageSrc={infernoBlobUrl}
        />
        {!isMobile && (
          <EyeVisual
            size={size}
            eyeRef={eyeRef2}
            pupilRef={pupilRef2}
            topTransform={currentTop}
            bottomTransform={currentBottom}
            isAngry={isAngry}
            isResetting={isResetting}
            showSky={showSky}
            showInferno={showInferno}
            glintState={glintState}
            onClick={handleEyeClick}
            isLeft={false}
            isMobile={isMobile}
            skyImageSrc={skyBlobUrl}
            infernoImageSrc={infernoBlobUrl}
          />
        )}
      </Box>

      <Fade in={!isAngry} timeout={500}>
        <Typography
          variant="h3"
          sx={{
            color: "white",
            textAlign: "center",
            fontFamily: "inherit",
            direction: "rtl",
            mb: 0,
            width: "100%",
            visibility: isAngry ? "hidden" : "visible",
          }}
          dir="rtl"
        >
          من <span style={{ fontWeight: "bold", color: "#FFC400" }}>مادر</span>{" "}
          فرم ها هستم
        </Typography>
      </Fade>

      <Box
        sx={{
          width: "100%",
          maxWidth: 800,
          alignSelf: "center",
          display: "flex",
          flexDirection: "column",
          gap: 1,
          alignItems: "center",
        }}
      >
        {/* Fixed: Use state variable 'activeAudio' */}
        <Box
          sx={{
            width: "100%",
            display: isAngry ? "flex" : "none",
            justifyContent: "center",
            mt: 2,
          }}
        >
          <AudioVisualizer audioElement={activeAudio} isActive={isAngry} />
        </Box>

        <Box sx={{ width: "100%", display: !isAngry ? "block" : "none" }}>
          <InputSection
            inputRef={inputRef}
            value={inputValue}
            onChange={handleInput}
            onClick={handleClick}
            onNewMessage={handleNewMessage}
            isLoading={isLoading}
            setIsLoading={setIsLoading}
            loadHistory={loadHistory}
            showSnackbar={showSnackbar}
          />
          <Box
            sx={{
              width: "100%",
              height: chatVisible ? 200 : 0,
              overflow: "hidden",
              transition: "height 0.5s ease",
              mb: 2,
            }}
          >
            <ChatHistory messages={messages} isLoading={isLoading} />
          </Box>
        </Box>
      </Box>

      <canvas ref={canvasRef} style={{ display: "none" }} />
    </Box>
  );
}


==================================================

FILE: src\components\animatedEye\components\AudioVisualizer.tsx
----------------------------------------
import React, { useEffect, useRef } from "react";
import { Box } from "@mui/material";

interface AudioVisualizerProps {
  audioElement: HTMLAudioElement | null;
  isActive: boolean;
}

interface WindowWithWebkit extends Window {
  webkitAudioContext: typeof AudioContext;
}
// Helper for rounded rectangles
function drawRoundedRect(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  radius: number
) {
  if (height < radius * 2) radius = height / 2;
  ctx.beginPath();
  ctx.roundRect(x, y, width, height, radius);
  ctx.fill();
}

export default function AudioVisualizer({
  audioElement,
  isActive,
}: AudioVisualizerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationRef = useRef<number>(0);
  const audioCtxRef = useRef<AudioContext | null>(null);
  const sourceRef = useRef<MediaElementAudioSourceNode | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);

  useEffect(() => {
    if (!isActive || !audioElement || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // 1. Init Audio Context
    if (!audioCtxRef.current) {
      const AudioContextClass =
        window.AudioContext ||
        (window as unknown as WindowWithWebkit).webkitAudioContext;
      audioCtxRef.current = new AudioContextClass();
    }
    const audioCtx = audioCtxRef.current;

    // 2. Connect Source
    // 2. Connect Source with Gain (Volume Boost)
    if (!sourceRef.current) {
      try {
        analyserRef.current = audioCtx.createAnalyser();

        // Create Gain Node (Amplifier)
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 3; // <--- 1.5x Volume (150%)

        sourceRef.current = audioCtx.createMediaElementSource(audioElement);

        // Connect Chain: Source -> Gain -> Analyser -> Speakers
        sourceRef.current.connect(gainNode);
        gainNode.connect(analyserRef.current);
        analyserRef.current.connect(audioCtx.destination);
      } catch (err) {
        console.error("Visualizer connection error:", err);
        return;
      }
    }

    if (!analyserRef.current) return;

    // Use fewer bins for wider, cleaner bars
    analyserRef.current.fftSize = 64;
    const bufferLength = analyserRef.current.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const draw = () => {
      if (!isActive) return;

      animationRef.current = requestAnimationFrame(draw);

      if (analyserRef.current) {
        analyserRef.current.getByteFrequencyData(dataArray);
      }

      // Clear Canvas (Plain Black)
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Bar Width
      const barWidth = 8;
      const gap = 4;

      // Draw mirrored from center
      ctx.fillStyle = "white";

      for (let i = 0; i < bufferLength; i++) {
        // Scale height
        const value = dataArray[i];
        const barHeight = (value / 255) * canvas.height * 0.8; // Max 80% height

        // Don't draw if too small (noise floor)
        if (barHeight < 2) continue;

        // Calculate positions (Mirrored)
        const xRight = centerX + i * (barWidth + gap);
        const xLeft = centerX - (i + 1) * (barWidth + gap);
        const y = centerY - barHeight / 2;

        // Draw Right Bar (Round Tips)
        drawRoundedRect(ctx, xRight, y, barWidth, barHeight, barWidth / 2);

        // Draw Left Bar (Round Tips)
        drawRoundedRect(ctx, xLeft, y, barWidth, barHeight, barWidth / 2);
      }
    };

    draw();

    return () => {
      cancelAnimationFrame(animationRef.current);
    };
  }, [isActive, audioElement]);

  return (
    <Box
      sx={{
        width: "100%",
        maxWidth: 600,
        height: 100,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        background: "black", // Plain black
        borderRadius: 4,
        overflow: "hidden",
        // No shadow, no border
      }}
    >
      <canvas
        ref={canvasRef}
        width={600}
        height={100}
        style={{ width: "100%", height: "100%" }}
      />
    </Box>
  );
}


==================================================

FILE: src\components\animatedEye\components\ChatHistory.tsx
----------------------------------------
// FILE: src\components\animatedEye\components\ChatHistory.tsx
// Optimized: React.memo + useMemo (no react-window; simple for short histories)
import React, {
  useRef,
  useEffect,
  useState,
  useCallback,
  useMemo,
} from "react";
import { Box, Typography } from "@mui/material";
import ReactMarkdown from "react-markdown";

export type ChatMessage = { role: "user" | "assistant"; text: string };

interface ChatHistoryProps {
  messages: ChatMessage[];
  isLoading?: boolean;
}

export default React.memo(function ChatHistory({
  // Skips re-render if props unchanged
  messages,
  isLoading = false,
}: ChatHistoryProps) {
  const chatRef = useRef<HTMLDivElement>(null);
  const [showTopFade, setShowTopFade] = useState(false);
  const [showBottomFade, setShowBottomFade] = useState(false);

  // Memoize JSX (compute once per messages change)
  const renderedMessages = useMemo(
    () =>
      messages
        .filter((msg) => msg.role === "assistant")
        .map((msg, index) => (
          <Box
            key={`${msg.role}-${index}`}
            sx={{
              p: 2,
              width: "100%",
              bgcolor: "transparent",
              color: "white",
              direction: "rtl",
              opacity: 1,
              transform: "translateY(0)",
              transition: "opacity 0.3s ease, transform 0.3s ease",
              "&:not(:last-child)": {
                animationDelay: `${index * 0.1}s`,
              },
            }}
          >
            <div
              dir="rtl"
              style={{
                direction: "rtl",
                textAlign: "right",
                width: "100%",
                unicodeBidi: "plaintext",
              }}
            >
              <ReactMarkdown
                components={{
                  h1: ({ children }) => (
                    <h1
                      dir="rtl"
                      style={{
                        color: "white",
                        fontSize: "1.5em",
                        margin: "0.5em 0",
                        direction: "rtl",
                        textAlign: "right",
                        unicodeBidi: "plaintext",
                        width: "100%",
                        fontWeight: "bold",
                        lineHeight: 1.2,
                      }}
                    >
                      {children}
                    </h1>
                  ),
                  h2: ({ children }) => (
                    <h2
                      dir="rtl"
                      style={{
                        color: "white",
                        fontSize: "1.2em",
                        margin: "0.5em 0",
                        direction: "rtl",
                        textAlign: "right",
                        unicodeBidi: "plaintext",
                        width: "100%",
                        fontWeight: "bold",
                        lineHeight: 1.3,
                      }}
                    >
                      {children}
                    </h2>
                  ),
                  h3: ({ children }) => (
                    <h3
                      dir="rtl"
                      style={{
                        color: "white",
                        fontSize: "1.1em",
                        margin: "0.5em 0",
                        direction: "rtl",
                        textAlign: "right",
                        unicodeBidi: "plaintext",
                        width: "100%",
                        fontWeight: "bold",
                        lineHeight: 1.4,
                      }}
                    >
                      {children}
                    </h3>
                  ),
                  p: ({ children }) => (
                    <p
                      dir="rtl"
                      style={{
                        margin: "0.5em 0",
                        lineHeight: 1.6,
                        direction: "rtl",
                        textAlign: "right",
                        unicodeBidi: "plaintext",
                        width: "100%",
                        color: "white",
                        fontSize: "1em",
                      }}
                    >
                      {children}
                    </p>
                  ),
                  ul: ({ children }) => (
                    <ul
                      dir="rtl"
                      style={{
                        margin: "0.5em 0",
                        paddingRight: "1.5em",
                        direction: "rtl",
                        textAlign: "right",
                        width: "100%",
                      }}
                    >
                      {children}
                    </ul>
                  ),
                  ol: ({ children }) => (
                    <ol
                      dir="rtl"
                      style={{
                        margin: "0.5em 0",
                        paddingRight: "1.5em",
                        direction: "rtl",
                        textAlign: "right",
                        width: "100%",
                      }}
                    >
                      {children}
                    </ol>
                  ),
                  li: ({ children }) => (
                    <li
                      dir="rtl"
                      style={{
                        direction: "rtl",
                        textAlign: "right",
                        marginBottom: "0.25em",
                        width: "100%",
                      }}
                    >
                      {children}
                    </li>
                  ),
                  strong: ({ children }) => (
                    <strong style={{ fontWeight: "bold", color: "#FFD700" }}>
                      {children}
                    </strong>
                  ),
                  em: ({ children }) => (
                    <em style={{ fontStyle: "italic", color: "white" }}>
                      {children}
                    </em>
                  ),
                }}
              >
                {msg.text}
              </ReactMarkdown>
            </div>
          </Box>
        )),
    [messages] // Re-compute only if messages change
  );

  const handleScroll = useCallback(() => {
    if (!chatRef.current) return;
    const { scrollTop, scrollHeight, clientHeight } = chatRef.current;
    setShowTopFade(scrollTop > 0);
    setShowBottomFade(scrollTop < scrollHeight - clientHeight - 1);
  }, []);

  // Auto-scroll to bottom
  useEffect(() => {
    if (chatRef.current) {
      chatRef.current.scrollTop = chatRef.current.scrollHeight;
    }
    setTimeout(handleScroll, 0);
  }, [renderedMessages.length, isLoading, handleScroll]);

  // Scroll listener
  useEffect(() => {
    const ref = chatRef.current;
    if (ref) {
      ref.addEventListener("scroll", handleScroll);
      handleScroll();
      return () => ref.removeEventListener("scroll", handleScroll);
    }
  }, [handleScroll]);

  // Initial fade
  useEffect(() => {
    if (renderedMessages.length > 0 && chatRef.current) {
      handleScroll();
    }
  }, [renderedMessages, handleScroll]);

  return (
    <Box
      sx={{
        width: "100%",
        height: 200,
        position: "relative",
        overflow: "hidden",
        backgroundColor: "black",
        borderRadius: 1,
      }}
    >
      {/* Top fade */}
      <Box
        sx={{
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          height: 30,
          pointerEvents: "none",
          background: "linear-gradient(to bottom, black, transparent)",
          zIndex: 2,
          opacity: showTopFade ? 1 : 0,
          transition: "opacity 0.3s ease",
        }}
      />
      {/* Scrollable chat */}
      <Box
        ref={chatRef}
        sx={{
          width: "100%",
          height: "100%",
          overflowY: "auto",
          color: "white",
          p: 1,
          direction: "rtl",
          scrollbarWidth: "none" as const,
          msOverflowStyle: "none" as const,
          "&::-webkit-scrollbar": { display: "none" },
          "& *::-webkit-scrollbar": { display: "none" },
        }}
      >
        <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
          {renderedMessages}
        </Box>
      </Box>
      {/* Empty state */}
      {renderedMessages.length === 0 && !isLoading && (
        <Box
          sx={{
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          }}
        >
          <Typography variant="body2" color="text.secondary" align="center">
            چت شروع نشده...
          </Typography>
        </Box>
      )}
      {/* Bottom fade */}
      <Box
        sx={{
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          height: 30,
          pointerEvents: "none",
          background: "linear-gradient(to top, black, transparent)",
          zIndex: 2,
          opacity: showBottomFade ? 1 : 0,
          transition: "opacity 0.3s ease",
        }}
      />
    </Box>
  );
});


==================================================

FILE: src\components\animatedEye\components\EyeVisual.tsx
----------------------------------------
import React from "react";
import { Box } from "@mui/material";
import { EyeVisualProps } from "../types";

// REMOVED: Imports of sky/inferno images from here.
// We will receive them as props now.

interface ExtendedEyeVisualProps extends EyeVisualProps {
  isAngry?: boolean;
  isResetting?: boolean;
  showSky?: boolean;
  showInferno?: boolean;
  glintState?: "normal" | "flash" | "growing";
  isLeft?: boolean;
  onClick?: () => void;
  isMobile?: boolean;
  // NEW PROPS for preloaded assets
  skyImageSrc?: string;
  infernoImageSrc?: string;
}

export function EyeVisual({
  size,
  eyeRef,
  pupilRef,
  topTransform,
  bottomTransform,
  isAngry = false,
  isResetting = false,
  showSky = false,
  showInferno = false,
  glintState = "normal",
  isLeft = false,
  onClick,
  isMobile = false,
  skyImageSrc, // <--- Receive here
  infernoImageSrc, // <--- Receive here
}: ExtendedEyeVisualProps) {
  const scleraMargin = size * 0.025;
  const lidTransitionDuration = isResetting ? "3s" : isAngry ? "1s" : "0.3s";

  let topLidTransform = topTransform;

  if (isAngry && !isResetting) {
    if (isMobile) {
      topLidTransform = `${topTransform} scale(1.2)`;
    } else {
      const rotation = isLeft ? "20deg" : "-20deg";
      topLidTransform = `${topTransform} rotate(${rotation}) scale(1.2)`;
    }
  }

  return (
    <Box
      ref={eyeRef}
      onClick={onClick}
      sx={{
        width: size,
        height: size,
        background: "black",
        borderRadius: "50%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        position: "relative",
        overflow: "hidden",
        cursor: "pointer",
        isolation: "isolate",
        filter: "none",
      }}
    >
      {/* Sclera */}
      <Box
        sx={{
          position: "absolute",
          top: scleraMargin,
          left: scleraMargin,
          width: size - 2 * scleraMargin,
          height: size - 2 * scleraMargin,
          background: "#FFFFFF",
          borderRadius: "50%",
          zIndex: 0,
          overflow: "hidden",
          filter: "brightness(100%) contrast(100%)",
          boxShadow: "inset 0 0 20px rgba(0,0,0,0.5)",
        }}
      >
        {/* Sky Image - Only render if source is available */}
        {skyImageSrc && (
          <Box
            sx={{
              position: "absolute",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              backgroundImage: `url(${skyImageSrc})`, // Use Prop
              backgroundSize: "cover",
              backgroundPosition: "center",
              opacity: showSky ? 1 : 0,
              transition: "opacity 1s ease-in-out",
              zIndex: 1,
              mixBlendMode: "normal",
            }}
          />
        )}
        {/* Inferno Image - Only render if source is available */}
        {infernoImageSrc && (
          <Box
            sx={{
              position: "absolute",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              backgroundImage: `url(${infernoImageSrc})`, // Use Prop
              backgroundSize: "cover",
              backgroundPosition: "center",
              opacity: showInferno ? 1 : 0,
              transition: "opacity 1s ease-in-out",
              zIndex: 2,
              mixBlendMode: "normal",
            }}
          />
        )}
      </Box>

      {/* Top lid */}
      <Box
        sx={{
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "50%",
          background: "black",
          transform: topLidTransform,
          transformOrigin: "bottom center",
          transition: `transform ${lidTransitionDuration} ease-in-out`,
          zIndex: 3,
          pointerEvents: "none",
        }}
      />
      {/* Pupil */}
      <Pupil
        size={size}
        pupilRef={pupilRef}
        glintState={glintState}
        isAngry={isAngry}
        isResetting={isResetting}
      />
      {/* Bottom lid */}
      <Box
        sx={{
          position: "absolute",
          bottom: 0,
          left: 0,
          width: "100%",
          height: "50%",
          background: "black",
          transform: bottomTransform,
          transition: `transform ${lidTransitionDuration} ease-in-out`,
          zIndex: 3,
          pointerEvents: "none",
        }}
      />
    </Box>
  );
}

function Pupil({
  size,
  pupilRef,
  glintState,
  isAngry,
  isResetting,
}: {
  size: number;
  pupilRef: React.RefObject<HTMLDivElement | null>;
  glintState: "normal" | "flash" | "growing";
  isAngry: boolean;
  isResetting: boolean;
}) {
  let glintColor = "white";
  let scale = 1.2;

  if (isAngry) {
    glintColor = "#FFD700";
  }

  if (glintState === "flash") {
    scale = 1.5;
    glintColor = "#8b0000";
  } else if (glintState === "growing") {
    scale = 2.2;
    glintColor = "#8b0000";
  }

  const isCentered = isAngry;
  const topPos = isCentered ? "50%" : "33%";
  const leftPos = isCentered ? "50%" : "33%";

  const transition = isResetting
    ? "all 3s ease-in-out 2s"
    : glintState === "growing"
    ? "all 12s ease-in"
    : "all 0.5s ease-out";

  return (
    <Box
      ref={pupilRef}
      sx={{
        width: size * 0.4,
        height: size * 0.4,
        background: "black",
        borderRadius: "50%",
        position: "absolute",
        zIndex: 2,
        pointerEvents: "none",
        overflow: "hidden",
      }}
    >
      {/* The Glint */}
      <Box
        sx={{
          width: size * 0.16,
          height: size * 0.16,
          background: glintColor,
          borderRadius: "50%",
          position: "absolute",
          top: topPos,
          left: leftPos,
          transform: `translate(-50%, -50%) scale(${scale})`,
          transition: transition,
          boxShadow:
            glintState !== "normal" && isAngry ? "0 0 10px #8b0000" : "none",
          transformOrigin: "center center",
        }}
      />
    </Box>
  );
}


==================================================

FILE: src\components\animatedEye\components\InputSection.tsx
----------------------------------------
import React from "react";
import { Box, TextField, IconButton, CircularProgress } from "@mui/material";
import SendIcon from "@mui/icons-material/Send";
import type { ChatMessage } from "./ChatHistory";
import { agent } from "@/lib/agent";

interface InputSectionProps {
  inputRef: React.RefObject<HTMLInputElement | null>;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onClick: () => void;
  onNewMessage: (msg: ChatMessage) => void;
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
  loadHistory: () => Promise<void>;
  showSnackbar?: (
    msg: string,
    severity?: "success" | "error" | "info" | "warning"
  ) => void;
}

export function InputSection({
  inputRef,
  value,
  onChange,
  onClick,
  onNewMessage,
  isLoading,
  setIsLoading,
  loadHistory,
  showSnackbar,
}: InputSectionProps) {
  const startPollingForAssistantResponse = () => {
    let pollCount = 0;
    const maxPolls = 30;
    const poll = async () => {
      await loadHistory();
      pollCount++;
      if (pollCount < maxPolls) setTimeout(poll, 1000);
      else showSnackbar?.("پاسخ با تأخیر دریافت شد یا خطایی رخ داد", "warning");
    };
    setTimeout(poll, 1000);
  };

  const handleSend = async () => {
    if (!value.trim() || isLoading) return;
    onClick();
    setIsLoading(true);
    try {
      const result = await agent(value);
      if (result && result.text_answer) {
        onNewMessage({ role: "assistant", text: result.text_answer });
      } else {
        showSnackbar?.("در حال پردازش درخواست شما...", "info");
        startPollingForAssistantResponse();
      }
    } catch (error) {
      console.error("Agent call failed:", error);
      showSnackbar?.("در حال پردازش... (اتصال برقرار شد)", "info");
      startPollingForAssistantResponse();
    } finally {
      setIsLoading(false);
      onChange({
        target: { value: "" },
      } as React.ChangeEvent<HTMLInputElement>);
    }
  };

  return (
    <Box
      sx={{
        display: "flex",
        gap: 1,
        alignItems: "center",
        // FIXED: Force 100% width regardless of parent padding

        width: "100%",
        maxWidth: "100%",
        boxSizing: "border-box",
        px: { xs: 0, sm: 0 }, // Ensure no internal padding on mobile
      }}
    >
      <IconButton
        onClick={handleSend}
        disabled={isLoading}
        sx={{
          borderRadius: "50%",
          width: 56,
          height: 56,
          bgcolor: "#FFC400",
          color: "black",
          "&:hover": { bgcolor: "#E6B800" },
          "&:disabled": { bgcolor: "#666", opacity: 0.7 },
          order: -1,
          flexShrink: 0,
          // Fix dimming on mobile
          filter: "brightness(100%) contrast(100%)",
          isolation: "isolate",
        }}
      >
        {isLoading ? (
          <CircularProgress size={28} sx={{ color: "black" }} />
        ) : (
          <SendIcon sx={{ fontSize: 32, transform: "rotate(180deg)" }} />
        )}
      </IconButton>

      <TextField
        inputRef={inputRef}
        fullWidth
        value={value}
        onChange={onChange}
        placeholder="بگو چی می‌خوای..."
        dir="rtl"
        disabled={isLoading}
        onKeyDown={(e) => {
          if (e.key === "Enter" && !e.shiftKey && !isLoading) {
            e.preventDefault();
            handleSend();
          }
        }}
        sx={{
          flexGrow: 1,
          "& .MuiOutlinedInput-root": {
            borderRadius: 28,
            backgroundColor: "grey.800",
            color: "white",
            "& fieldset": { borderColor: "grey.600" },
            "&:hover fieldset": { borderColor: "grey.400" },
            "&.Mui-focused fieldset": { borderColor: "#FFC400" },
          },
        }}
        InputProps={{ style: { color: "white" } }}
      />
    </Box>
  );
}


==================================================

FILE: src\components\animatedEye\hooks\useBlink.ts
----------------------------------------
import { useCallback, useState } from "react";

export function useBlink() {
  const [topTransform, setTopTransform] = useState("translateY(-100%)");
  const [bottomTransform, setBottomTransform] = useState("translateY(100%)");

  const closeEyes = useCallback(() => {
    setTopTransform("translateY(0%)");
    setBottomTransform("translateY(0%)");
  }, []);

  const openEyes = useCallback(() => {
    setTopTransform("translateY(-100%)");
    setBottomTransform("translateY(100%)");
  }, []);

  const squintEyes = useCallback(() => {
    setTopTransform("translateY(-35%)");
    setBottomTransform("translateY(85%)");
  }, []);

  const performBlink = useCallback(() => {
    closeEyes();
    // Increased from 150ms to 350ms to allow full closure (animation takes 300ms)
    setTimeout(() => openEyes(), 200);
  }, [closeEyes, openEyes]);

  // Blinks twice (timing adjusted for slower blinks)
  const doubleBlink = useCallback(() => {
    performBlink();
    setTimeout(() => performBlink(), 600);
  }, [performBlink]);

  return {
    topTransform,
    bottomTransform,
    performBlink,
    doubleBlink,
    openEyes,
    squintEyes,
    closeEyes,
  };
}


==================================================

FILE: src\components\animatedEye\hooks\useEyeListeners.ts
----------------------------------------
// Updated src/components/animatedEye/hooks/useEyeListeners.ts
import { useRef, useCallback, useEffect } from "react";
import type { UseEyeListenersProps } from "../types";
import { handleMouseLeave, handleMouseEnter } from "../utils/mouseUtils";
import { handleVisibilityChange } from "../utils/visibilityUtils";

export function useEyeListeners({
  isFocused,
  inputRef,
  doubleBlink,
  startRandomPupilMovement,
  stopRandomPupilMovement,
  handleFocus,
  handleBlur,
  handleMouseMove,
  pupilRef,
}: UseEyeListenersProps) {
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const isMouseOutsideRef = useRef(false);

  const handleVisibilityChangeCallback = useCallback(() => {
    handleVisibilityChange({
      isFocused,
      pupilRef,
      startRandomPupilMovement,
      stopRandomPupilMovement,
      doubleBlink,
      intervalRef,
      isMouseOutsideRef,
    });
  }, [
    isFocused,
    doubleBlink,
    startRandomPupilMovement,
    stopRandomPupilMovement,
    pupilRef,
    intervalRef, // Note: refs don't cause re-renders, but included for completeness
    isMouseOutsideRef,
  ]);

  const handleMouseLeaveDocumentCallback = useCallback(() => {
    handleMouseLeave({
      isFocused,
      pupilRef,
      startRandomPupilMovement,
      doubleBlink,
      intervalRef,
      isMouseOutsideRef,
    });
  }, [
    isFocused,
    doubleBlink,
    startRandomPupilMovement,
    pupilRef,
    intervalRef,
    isMouseOutsideRef,
  ]);

  const handleMouseEnterDocumentCallback = useCallback(() => {
    handleMouseEnter({
      stopRandomPupilMovement,
      intervalRef,
      isMouseOutsideRef,
    });
  }, [stopRandomPupilMovement, intervalRef, isMouseOutsideRef]);

  useEffect(() => {
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseleave", handleMouseLeaveDocumentCallback);
    document.addEventListener("mouseenter", handleMouseEnterDocumentCallback);
    document.addEventListener(
      "visibilitychange",
      handleVisibilityChangeCallback
    );

    const input = inputRef.current;
    if (input) {
      input.addEventListener("focus", handleFocus);
      input.addEventListener("blur", handleBlur);
    }

    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener(
        "mouseleave",
        handleMouseLeaveDocumentCallback
      );
      document.removeEventListener(
        "mouseenter",
        handleMouseEnterDocumentCallback
      );
      document.removeEventListener(
        "visibilitychange",
        handleVisibilityChangeCallback
      );

      if (input) {
        input.removeEventListener("focus", handleFocus);
        input.removeEventListener("blur", handleBlur);
      }

      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      stopRandomPupilMovement();
    };
  }, [
    handleMouseMove,
    handleMouseLeaveDocumentCallback,
    handleMouseEnterDocumentCallback,
    handleVisibilityChangeCallback,
    inputRef,
    handleFocus,
    handleBlur,
    stopRandomPupilMovement,
  ]);
}


==================================================

FILE: src\components\animatedEye\hooks\useInputFocus.ts
----------------------------------------
// FILE: src\components\animatedEye\hooks\useInputFocus.ts
// Reverted: Remove debounce entirely (immediate updates, no delay)
import { useCallback, useState } from "react";
import type { UseInputFocusProps } from "../types";
import { calculateCursorPosition } from "../utils/cursorUtils";

export function useInputFocus({
  updatePupilPosition,
  inputRef,
  canvasRef,
  isFocused,
}: UseInputFocusProps) {
  const [inputValue, setInputValue] = useState("");

  const updatePupilToInput = useCallback(() => {
    if (!isFocused || !inputRef.current || !canvasRef.current) return;
    const input = inputRef.current;
    const cursorPos = input.selectionStart || 0;
    if (cursorPos < 0) return;

    const canvas = canvasRef.current;
    const pos = calculateCursorPosition(input, cursorPos, canvas);
    if (pos) {
      updatePupilPosition(pos.x, pos.y);
    }
  }, [isFocused, updatePupilPosition, inputRef, canvasRef]);

  const handleInput = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      setInputValue(e.target.value);
      // REVERTED: Immediate call (no debounce/delay)
      updatePupilToInput();
    },
    [updatePupilToInput]
  );

  return {
    inputValue,
    handleInput,
    updatePupilToInput,
  };
}


==================================================

FILE: src\components\animatedEye\hooks\usePupilMovement.ts
----------------------------------------
import { useCallback, useRef } from "react";
import type { UsePupilMovementProps, EyeCenter } from "../types";
import {
  calculateEyeCenter,
  calculatePupilPosition,
} from "../utils/positionUtils";
export function usePupilMovement({
  size,
  eyeRef,
  isFocused,
}: UsePupilMovementProps) {
  const pupilRef = useRef<HTMLDivElement | null>(null);
  // Helper to get center
  const getEyeCenter = useCallback((): EyeCenter => {
    if (eyeRef.current) {
      const rect = eyeRef.current.getBoundingClientRect();
      return calculateEyeCenter(rect);
    }
    return { x: 0, y: 0 };
  }, [eyeRef]);
  // Move pupil towards a specific target (e.g. Mouse coordinates)
  const updatePupilPosition = useCallback(
    (targetX: number, targetY: number) => {
      if (!pupilRef.current) return;
      const eyeCenter = getEyeCenter();
      const { x: pupilX, y: pupilY } = calculatePupilPosition(
        eyeCenter,
        targetX,
        targetY,
        size
      );
      pupilRef.current.style.transform = `translate(${pupilX}px, ${pupilY}px)`;
      pupilRef.current.style.transition = "transform 0.1s linear"; // Fast follow
    },
    [getEyeCenter, size]
  );
  // Force pupil to specific offset (used for random synchronized movement)
  const setPupilOffset = useCallback(
    (x: number, y: number, transitionDuration: string = "2s") => {
      if (!pupilRef.current) return;
      pupilRef.current.style.transition = `transform ${transitionDuration} ease-in-out`;
      pupilRef.current.style.transform = `translate(${x}px, ${y}px)`;
    },
    []
  );
  // Handle standard mouse movement
  const handleMouseMove = useCallback(
    (event: MouseEvent) => {
      if (isFocused || !eyeRef.current || !pupilRef.current) return;
      updatePupilPosition(event.clientX, event.clientY);
    },
    [isFocused, updatePupilPosition, eyeRef]
  );
  return {
    pupilRef,
    updatePupilPosition,
    setPupilOffset,
    handleMouseMove,
  };
}


==================================================

FILE: src\components\animatedEye\types\index.ts
----------------------------------------
// src/components/animatedEye/types/index.ts
export interface AnimatedEyeProps {
  size?: number;
}

export interface EyeCenter {
  x: number;
  y: number;
}

export interface BlinkState {
  topTransform: string;
  bottomTransform: string;
  isSquinting: boolean;
}

export interface InputSectionProps {
  inputRef: React.RefObject<HTMLInputElement | null>;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onClick: () => void;
  onNewMessage: (msg: { role: "user" | "assistant"; text: string }) => void; // NEW
  isLoading: boolean; // NEW
  setIsLoading: (loading: boolean) => void; // NEW
  // REMOVED: showSnackbar – no frontend saves
}

export interface PupilProps {
  size: number;
  pupilRef: React.RefObject<HTMLDivElement | null>;
}

export interface EyeVisualProps {
  size: number;
  eyeRef: React.RefObject<HTMLDivElement | null>;
  pupilRef: React.RefObject<HTMLDivElement | null>;
  topTransform: string;
  bottomTransform: string;
}

export interface UsePupilMovementProps {
  size: number;
  eyeRef: React.RefObject<HTMLDivElement | null>;
  isFocused: boolean;
}

export interface UseInputFocusProps {
  updatePupilPosition: (x: number, y: number) => void;
  inputRef: React.RefObject<HTMLInputElement | null>;
  canvasRef: React.RefObject<HTMLCanvasElement | null>;
  isFocused: boolean;
}

export interface UseEyeListenersProps {
  isFocused: boolean;
  eyeRef: React.RefObject<HTMLDivElement | null>;
  inputRef: React.RefObject<HTMLInputElement | null>;
  doubleBlink: () => void;
  startRandomPupilMovement: () => void;
  stopRandomPupilMovement: () => void;
  handleFocus: () => void;
  handleBlur: () => void;
  handleMouseMove: (event: MouseEvent) => void;
  pupilRef: React.RefObject<HTMLDivElement | null>;
}

import type { RefObject } from "react";
export interface PupilHomeOptions {
  pupilRef: RefObject<HTMLElement | null>;
  startRandomPupilMovement: () => void;
}

export interface BlinkingOptions {
  intervalRef: { current: NodeJS.Timeout | null };
  doubleBlink: () => void;
  isMouseOutsideRef: { current: boolean };
}
export interface MouseOutsideOptions {
  isFocused: boolean;
  pupilRef: RefObject<HTMLElement | null>;
  startRandomPupilMovement: () => void;
  doubleBlink: () => void;
  intervalRef: { current: NodeJS.Timeout | null };
  isMouseOutsideRef: { current: boolean };
}

export interface VisibilityOptions {
  isFocused: boolean;
  pupilRef: RefObject<HTMLElement | null>;
  startRandomPupilMovement: () => void;
  stopRandomPupilMovement: () => void;
  doubleBlink: () => void;
  intervalRef: { current: NodeJS.Timeout | null };
  isMouseOutsideRef: { current: boolean };
}
export interface MouseEnterOptions {
  stopRandomPupilMovement: () => void;
  intervalRef: { current: NodeJS.Timeout | null };
  isMouseOutsideRef: { current: boolean };
}


==================================================

FILE: src\components\animatedEye\utils\blinkingUtils.ts
----------------------------------------
import type {BlinkingOptions} from "../types"
export function startBlinkingInterval({
  intervalRef,
  doubleBlink,
  isMouseOutsideRef,
}: BlinkingOptions): void {
  if (intervalRef.current) clearInterval(intervalRef.current);
  intervalRef.current = setInterval(() => {
    if (isMouseOutsideRef.current) {
      doubleBlink();
    }
  }, 4000);
  doubleBlink();
}

export function stopBlinkingInterval(intervalRef: {
  current: NodeJS.Timeout | null;
}): void {
  if (intervalRef.current) {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  }
}


==================================================

FILE: src\components\animatedEye\utils\cursorUtils.ts
----------------------------------------
// src/components/animatedEye/utils/cursorUtils.ts
export function calculateCursorPosition(
  input: HTMLInputElement,
  cursorPos: number,
  canvas: HTMLCanvasElement
): { x: number; y: number } | null {
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;

  const style = window.getComputedStyle(input);
  ctx.font = style.font;
  ctx.direction = "rtl";

  const textBefore = input.value.substring(0, cursorPos);
  const textWidth = ctx.measureText(textBefore).width;

  const inputRect = input.getBoundingClientRect();
  const paddingRight = parseFloat(style.paddingRight) || 0;
  const cursorX = inputRect.right - paddingRight - textWidth;
  const cursorY = inputRect.top + inputRect.height / 2;

  return { x: cursorX, y: cursorY };
}


==================================================

FILE: src\components\animatedEye\utils\intervalUtils.ts
----------------------------------------
// src/components/animatedEye/utils/intervalUtils.ts
export interface RandomMoveOptions {
  randomMoveIntervalRef: { current: NodeJS.Timeout | null };
  pupilRef: { current: HTMLElement | null };
  generateRandomPupilPosition: (size: number) => { x: number; y: number };
  size: number;
  isFocused: boolean;
}

export function startRandomPupilMovement({
  randomMoveIntervalRef,
  pupilRef,
  generateRandomPupilPosition,
  size,
  isFocused,
}: RandomMoveOptions): void {
  if (randomMoveIntervalRef.current) {
    clearInterval(randomMoveIntervalRef.current);
  }

  randomMoveIntervalRef.current = setInterval(() => {
    if (!pupilRef.current || isFocused) return;

    const randomPos = generateRandomPupilPosition(size);
    pupilRef.current.style.transition = "all 2s ease-in-out";
    pupilRef.current.style.transform = `translate(${randomPos.x}px, ${randomPos.y}px)`;
  }, 2000);
}

export function stopRandomPupilMovement({
  randomMoveIntervalRef,
  pupilRef,
}: Pick<RandomMoveOptions, "randomMoveIntervalRef" | "pupilRef">): void {
  if (randomMoveIntervalRef.current) {
    clearInterval(randomMoveIntervalRef.current);
    randomMoveIntervalRef.current = null;
  }
  if (pupilRef.current) {
    pupilRef.current.style.transition = "all 0.1s linear";
  }
}


==================================================

FILE: src\components\animatedEye\utils\mouseUtils.ts
----------------------------------------
// src/components/animatedEye/utils/mouseUtils.ts

import type { MouseOutsideOptions, MouseEnterOptions } from "../types";
import { centerPupil } from "./pupilUtils";
import { startBlinkingInterval, stopBlinkingInterval } from "./blinkingUtils";

export function handleMouseLeave({
  isFocused,
  pupilRef,
  startRandomPupilMovement,
  doubleBlink,
  intervalRef,
  isMouseOutsideRef,
}: MouseOutsideOptions): void {
  if (isFocused) return;
  isMouseOutsideRef.current = true;
  centerPupil({ pupilRef, startRandomPupilMovement });
  startBlinkingInterval({ intervalRef, doubleBlink, isMouseOutsideRef });
}

export function handleMouseEnter({
  stopRandomPupilMovement,
  intervalRef,
  isMouseOutsideRef,
}: MouseEnterOptions): void {
  isMouseOutsideRef.current = false;
  stopRandomPupilMovement();
  stopBlinkingInterval(intervalRef);
}


==================================================

FILE: src\components\animatedEye\utils\positionUtils.ts
----------------------------------------
// src/components/animatedEye/utils/positionUtils.ts
import type { EyeCenter } from "../types";

export function calculateEyeCenter(eyeRect: DOMRect): EyeCenter {
  return {
    x: eyeRect.left + eyeRect.width / 2,
    y: eyeRect.top + eyeRect.height / 2,
  };
}

export function calculatePupilPosition(
  eyeCenter: EyeCenter,
  targetX: number,
  targetY: number,
  size: number
): { x: number; y: number } {
  const dx = targetX - eyeCenter.x;
  const dy = targetY - eyeCenter.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);
  const moveDistance = Math.min(distance / 5, size * 0.2);
  const pupilX = Math.cos(angle) * moveDistance;
  const pupilY = Math.sin(angle) * moveDistance;
  return { x: pupilX, y: pupilY };
}

export function generateRandomPupilPosition(size: number): {
  x: number;
  y: number;
} {
  const maxMove = size * 0.08;
  const randomX = (Math.random() - 0.5) * 2 * maxMove;
  const randomY = (Math.random() - 0.5) * 2 * maxMove;
  return { x: randomX, y: randomY };
}


==================================================

FILE: src\components\animatedEye\utils\pupilUtils.ts
----------------------------------------
// src/components/animatedEye/utils/pupilUtils.ts

import type { PupilHomeOptions } from "../types";

export function centerPupil({
  pupilRef,
  startRandomPupilMovement,
}: PupilHomeOptions): void {
  if (pupilRef.current) {
    pupilRef.current.style.transition = "all 0.5s ease-in-out";
    pupilRef.current.style.transform = "translate(0px, 0px)";
    setTimeout(() => {
      if (pupilRef.current) {
        pupilRef.current.style.transition = "all 0.1s linear";
      }
      startRandomPupilMovement();
    }, 500);
  }
}


==================================================

FILE: src\components\animatedEye\utils\visibilityUtils.ts
----------------------------------------
// src/components/animatedEye/utils/visibilityUtils.ts

import type { VisibilityOptions } from "../types";
import { centerPupil } from "./pupilUtils";
import { startBlinkingInterval, stopBlinkingInterval } from "./blinkingUtils";

export function handleVisibilityChange({
  isFocused,
  pupilRef,
  startRandomPupilMovement,
  stopRandomPupilMovement,
  doubleBlink,
  intervalRef,
  isMouseOutsideRef,
}: VisibilityOptions): void {
  if (document.visibilityState === "hidden" && !isFocused) {
    isMouseOutsideRef.current = true;
    centerPupil({ pupilRef, startRandomPupilMovement });
    startBlinkingInterval({ intervalRef, doubleBlink, isMouseOutsideRef });
  } else if (document.visibilityState === "visible") {
    isMouseOutsideRef.current = false;
    stopRandomPupilMovement();
    stopBlinkingInterval(intervalRef);
  }
}


==================================================

FILE: src\components\CustomAccordion.tsx
----------------------------------------
"use client";

import React, { useState } from "react";
import { Box, Typography, IconButton, Collapse } from "@mui/material";
import {
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
} from "@mui/icons-material";

interface CustomAccordionProps {
  title: string;
  children: React.ReactNode;
  defaultExpanded?: boolean;
  sx?: object;
}

export default function CustomAccordion({
  title,
  children,
  defaultExpanded = true,
  sx,
}: CustomAccordionProps) {
  const [expanded, setExpanded] = useState(defaultExpanded);

  const handleToggle = () => {
    setExpanded(!expanded);
  };

  return (
    <Box
      sx={{
        width: "100%",
        borderRadius: 4,
        overflow: "hidden",
        backgroundColor: "rgba(255, 255, 255, 0.05)",
        ...sx,
      }}
    >
      {/* Summary */}
      <Box
        onClick={handleToggle}
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          p: 2,
          cursor: "pointer",
          backgroundColor: "rgba(0, 0, 0, 0.1)",
          "&:hover": {
            backgroundColor: "rgba(0, 0, 0, 0.15)",
          },
        }}
      >
        <Typography
          variant="h6"
          sx={{
            fontSize: { xs: "1.25rem", sm: "1.5rem" },
            flexGrow: 1,
          }}
        >
          {title}
        </Typography>
        <IconButton size="small">
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>

      {/* Details - Collapsible */}
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <Box sx={{ p: 2 }}>{children}</Box>
      </Collapse>
    </Box>
  );
}


==================================================

FILE: src\components\dynamicForm\components\fieldInput.tsx
----------------------------------------
import React from "react";
import type { FieldInputProps } from "../types";
import TextInput from "./fieldInputs/TextInput";
import NumberInput from "./fieldInputs/NumberInput";
import DateInput from "./fieldInputs/DateInput";
import CheckboxInput from "./fieldInputs/CheckboxInput";
import SelectInput from "./fieldInputs/SelectInput";
import EntityReferenceInput from "./fieldInputs/EntityReferenceInput";
import TextareaInput from "./fieldInputs/TextareaInput";
import EmailInput from "./fieldInputs/EmailInput";
import PasswordInput from "./fieldInputs/PasswordInput";
import UrlInput from "./fieldInputs/UrlInput";
import DatetimeInput from "./fieldInputs/DatetimeInput";
import TimeInput from "./fieldInputs/TimeInput";
import MultiselectInput from "./fieldInputs/MultiselectInput";
import RadioInput from "./fieldInputs/RadioInput";
import FileInput from "./fieldInputs/FileInput";
import ImageInput from "./fieldInputs/ImageInput";
import HiddenInput from "./fieldInputs/HiddenInput";

const FieldInput: React.FC<FieldInputProps> = ({
  field,
  baseName,
  isItem = false,
  entityOptions,
  errors,
  ...commonProps
}) => {
  const fieldKey = field.label;
  const fullName = isItem ? `${baseName}.${fieldKey}` : fieldKey;
  const fieldProps = {
    ...commonProps,
    name: fullName,
    label: field.label,
    required: field.required ?? false,
    errors,
  };

  // FIXED: Use false for loading since it's not per-field; propagate from parent if needed
  const entityLoading = false;

  switch (field.type) {
    case "text":
      return <TextInput {...fieldProps} />;
    case "textarea":
      return <TextareaInput {...fieldProps} />;
    case "number":
    case "integer":
    case "decimal":
      return <NumberInput {...fieldProps} />;
    case "email":
      return <EmailInput {...fieldProps} />;
    case "password":
      return <PasswordInput {...fieldProps} />;
    case "url":
      return <UrlInput {...fieldProps} />;
    case "date":
      return <DateInput {...fieldProps} />;
    case "datetime":
      return <DatetimeInput {...fieldProps} />;
    case "time":
      return <TimeInput {...fieldProps} />;
    case "select":
      return <SelectInput options={field.options || []} {...fieldProps} />;
    case "multiselect":
      return <MultiselectInput options={field.options || []} {...fieldProps} />;
    case "checkbox":
      return <CheckboxInput {...fieldProps} />;
    case "radio":
      return <RadioInput options={field.options || []} {...fieldProps} />;
    case "file":
      return <FileInput {...fieldProps} />;
    case "image":
      return <ImageInput {...fieldProps} />;
    case "hidden":
      return <HiddenInput {...fieldProps} />;
    case "reference":
      return (
        <EntityReferenceInput
          options={entityOptions[field.id] || []}
          loading={entityLoading}
          {...fieldProps}
          field={field}
        />
      );
    default:
      return <div>Unsupported field type: {field.type}</div>;
  }
};

export default FieldInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\CheckboxInput.tsx
----------------------------------------
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { Checkbox, FormControlLabel, FormHelperText } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const CheckboxInput: React.FC<CommonFieldProps> = ({ name, label }) => {
  // Removed unused errors
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <>
          <FormControlLabel
            control={
              <Checkbox
                checked={!!value}
                onChange={(e) => onChange(e.target.checked)}
              />
            }
            label={label}
          />
          {error && <FormHelperText error>{error.message}</FormHelperText>}
        </>
      )}
    />
  );
};

export default CheckboxInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\DateInput.tsx
----------------------------------------
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const DateInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          type="date"
          InputLabelProps={{ shrink: true }}
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]} // Fallback to prop if needed
          helperText={error?.message || (errors?.[name]?.message as string)}
        />
      )}
    />
  );
};

export default DateInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\DatetimeInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/DatetimeInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const DatetimeInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          type="datetime-local"
          InputLabelProps={{ shrink: true }}
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
        />
      )}
    />
  );
};

export default DatetimeInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\EmailInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/EmailInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const EmailInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          type="email"
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
        />
      )}
    />
  );
};

export default EmailInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\EntityReferenceInput.tsx
----------------------------------------
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { Autocomplete, TextField, CircularProgress } from "@mui/material";
import type { EntityFieldProps, EntityOption, Field } from "../../types";

const EntityReferenceInput: React.FC<
  EntityFieldProps & { field: Field; loading?: boolean }
> = ({ name, label, required, options, errors, field, loading = false }) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => {
        const selectedOption =
          options.find((opt: EntityOption) => opt.$id === value) || null;

        const getOptionLabel = (option: EntityOption) => {
          if (field.type !== "reference" || !field.displayField) {
            return option.name || option.$id;
          }
          return option.name || option.$id;
        };

        return (
          <Autocomplete
            options={options as EntityOption[]}
            getOptionLabel={getOptionLabel}
            renderOption={(props, option) => {
              const { key: _, ...safeProps } = props; // FIXED: Use _ for unused
              return (
                <li key={option.$id} {...safeProps}>
                  {getOptionLabel(option)}
                </li>
              );
            }}
            isOptionEqualToValue={(option, value) => option.$id === value.$id}
            renderInput={(params) => (
              <TextField
                {...params}
                label={label}
                required={required}
                error={!!error || !!errors?.[name]}
                helperText={
                  error?.message || (errors?.[name]?.message as string)
                }
                InputProps={{
                  ...params.InputProps,
                  endAdornment: (
                    <>
                      {loading ? (
                        <CircularProgress color="inherit" size={20} />
                      ) : null}
                      {params.InputProps.endAdornment}
                    </>
                  ),
                }}
              />
            )}
            onChange={(_, selected: EntityOption | null) =>
              onChange(selected?.$id || "")
            }
            value={selectedOption}
            fullWidth
            loading={loading}
          />
        );
      }}
    />
  );
};

export default EntityReferenceInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\FieldInput.tsx
----------------------------------------
import React from "react";
// import { buildFieldKey } from "../../utils/formUtils"; // REMOVED: No longer needed (raw labels now)
import type { FieldInputProps } from "../../types";
import TextInput from "./TextInput";
import NumberInput from "./NumberInput";
import DateInput from "./DateInput";
import CheckboxInput from "./CheckboxInput";
import SelectInput from "./SelectInput";
import EntityReferenceInput from "./EntityReferenceInput"; // Now for 'reference'
import TextareaInput from "./TextareaInput";
import EmailInput from "./EmailInput";
import PasswordInput from "./PasswordInput";
import UrlInput from "./UrlInput";
import DatetimeInput from "./DatetimeInput";
import TimeInput from "./TimeInput";
import MultiselectInput from "./MultiselectInput";
import RadioInput from "./RadioInput";
import FileInput from "./FileInput";
import ImageInput from "./ImageInput";
import HiddenInput from "./HiddenInput";

const FieldInput: React.FC<FieldInputProps> = ({
  field,
  baseName,
  isItem = false,
  entityOptions,
  errors,
  ...commonProps
}) => {
  // CHANGED: Use raw field.label as key (with spaces) instead of buildFieldKey
  const fieldKey = field.label; // Raw label with spaces
  const fullName = isItem ? `${baseName}.${fieldKey}` : fieldKey;
  const fieldProps = {
    ...commonProps,
    name: fullName,
    label: field.label,
    required: field.required ?? false,
    errors,
  };

  switch (field.type) {
    case "text":
      return <TextInput {...fieldProps} />;
    case "textarea":
      return <TextareaInput {...fieldProps} />;
    case "number":
    case "integer":
    case "decimal": // Alias to number
      return <NumberInput {...fieldProps} />;
    case "email":
      return <EmailInput {...fieldProps} />;
    case "password":
      return <PasswordInput {...fieldProps} />;
    case "url":
      return <UrlInput {...fieldProps} />;
    case "date":
      return <DateInput {...fieldProps} />;
    case "datetime":
      return <DatetimeInput {...fieldProps} />;
    case "time":
      return <TimeInput {...fieldProps} />;
    case "select":
      return <SelectInput options={field.options || []} {...fieldProps} />;
    case "multiselect":
      return <MultiselectInput options={field.options || []} {...fieldProps} />;
    case "checkbox":
      return <CheckboxInput {...fieldProps} />;
    case "radio":
      return <RadioInput options={field.options || []} {...fieldProps} />;
    case "file":
      return <FileInput {...fieldProps} />;
    case "image":
      return <ImageInput {...fieldProps} />;
    case "hidden":
      return <HiddenInput {...fieldProps} />;
    case "reference": // Aligned from 'entity_reference'
      return (
        <EntityReferenceInput
          options={entityOptions[field.id] || []}
          {...fieldProps}
          field={field}
        />
      );
    default:
      return <div>Unsupported field type: {field.type}</div>;
  }
};

export default FieldInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\FileInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/FileInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";
import type { ChangeEvent } from "react";

const FileInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={(e: ChangeEvent<HTMLInputElement>) =>
            onChange(e.target.files?.[0]?.name || "")
          } // Store filename
          label={label}
          type="file"
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
          InputLabelProps={{ shrink: true }}
        />
      )}
    />
  );
};

export default FileInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\HiddenInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/HiddenInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import type { CommonFieldProps } from "../../types";

const HiddenInput: React.FC<CommonFieldProps> = ({ name }) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field }) => <input type="hidden" {...field} />} // Invisible
    />
  );
};

export default HiddenInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\ImageInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/ImageInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";
import type { ChangeEvent } from "react";

const ImageInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={(e: ChangeEvent<HTMLInputElement>) =>
            onChange(e.target.files?.[0]?.name || "")
          }
          label={label}
          type="file"
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
          InputLabelProps={{ shrink: true }}
          inputProps={{ accept: "image/*" }}
        />
      )}
    />
  );
};

export default ImageInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\MultiselectInput.tsx
----------------------------------------
// FILE: src/components/dynamicForm/components/fieldInputs/MultiselectInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import {
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormHelperText,
  Box,
  Chip,
} from "@mui/material";
import type { SelectFieldProps } from "../../types";

const MultiselectInput: React.FC<SelectFieldProps> = ({
  name,
  label,
  required,
  options,
  errors,
}) => {
  const { control } = useFormContext();

  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => {
        // FIXED: Ensure value is always an array (handles undefined/null)
        const safeValue = Array.isArray(value) ? value : [];

        return (
          <FormControl
            fullWidth
            required={required}
            error={!!error || !!errors?.[name]}
          >
            <InputLabel>{label}</InputLabel>
            <Select
              multiple
              value={safeValue} // ← Now guaranteed array
              label={label}
              onChange={(e) => {
                // FIXED: Extract unique values as array
                const selected = Array.isArray(e.target.value)
                  ? e.target.value
                  : [];
                onChange(selected);
              }}
              renderValue={(selected) => (
                <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5 }}>
                  {(selected as string[]).map((value) => (
                    <Chip key={value} label={value} size="small" />
                  ))}
                </Box>
              )}
            >
              {options?.map((opt: string, index: number) => (
                <MenuItem key={`${opt}-${index}`} value={opt}>
                  {opt}
                </MenuItem>
              ))}
            </Select>
            {(error || errors?.[name]) && (
              <FormHelperText>
                {error?.message ||
                  (errors?.[name] as { message?: string })?.message}
              </FormHelperText>
            )}
          </FormControl>
        );
      }}
    />
  );
};

export default MultiselectInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\NumberInput.tsx
----------------------------------------
import React from "react";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const NumberInput: React.FC<CommonFieldProps> = ({
  register,
  name,
  label,
  required,
  errors,
}) => (
  <TextField
    {...(register && register(name, { valueAsNumber: true }))}
    type="number"
    label={label}
    required={required}
    fullWidth
    error={!!errors?.[name]}
    helperText={errors?.[name]?.message as string}
  />
);

export default NumberInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\PasswordInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/PasswordInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const PasswordInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          type="password"
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
        />
      )}
    />
  );
};

export default PasswordInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\RadioInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/RadioInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import {
  FormControl,
  FormLabel,
  FormControlLabel,
  RadioGroup,
  Radio,
  FormHelperText,
} from "@mui/material";
import type { SelectFieldProps } from "../../types";

const RadioInput: React.FC<SelectFieldProps> = ({
  name,
  label,
  required,
  options,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <FormControl
          fullWidth
          required={required}
          error={!!error || !!errors?.[name]}
        >
          <FormLabel>{label}</FormLabel>
          <RadioGroup
            value={value || ""}
            onChange={(e) => onChange(e.target.value)}
          >
            {options?.map((opt: string) => (
              <FormControlLabel
                key={opt}
                value={opt}
                control={<Radio />}
                label={opt}
              />
            ))}
          </RadioGroup>
          {(error || errors?.[name]) && (
            <FormHelperText>
              {error?.message ||
                (errors?.[name] as { message?: string })?.message}
            </FormHelperText>
          )}
        </FormControl>
      )}
    />
  );
};

export default RadioInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\SelectInput.tsx
----------------------------------------
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import {
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormHelperText,
} from "@mui/material";
import type { SelectFieldProps } from "../../types";

const SelectInput: React.FC<SelectFieldProps> = ({
  name,
  label,
  required,
  options,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <FormControl
          fullWidth
          required={required}
          error={!!error || !!errors?.[name]}
        >
          <InputLabel>{label}</InputLabel>
          <Select value={value ?? ""} label={label} onChange={onChange}>
            {options.map((opt) => (
              <MenuItem key={opt} value={opt}>
                {opt}
              </MenuItem>
            ))}
          </Select>
          {(error || errors?.[name]) && (
            <FormHelperText>
              {error?.message || (errors?.[name]?.message as string)}
            </FormHelperText>
          )}
        </FormControl>
      )}
    />
  );
};

export default SelectInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\TextareaInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/TextareaInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const TextareaInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          multiline
          rows={4}
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
        />
      )}
    />
  );
};

export default TextareaInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\TextInput.tsx
----------------------------------------
import React from "react";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const TextInput: React.FC<CommonFieldProps> = ({
  register,
  name,
  label,
  required,
  errors,
}) => (
  <TextField
    {...(register && register(name))}
    label={label}
    required={required}
    fullWidth
    error={!!errors?.[name]}
    helperText={errors?.[name]?.message as string}
  />
);

export default TextInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\TimeInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/TimeInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const TimeInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          type="time"
          InputLabelProps={{ shrink: true }}
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
        />
      )}
    />
  );
};

export default TimeInput;


==================================================

FILE: src\components\dynamicForm\components\fieldInputs\UrlInput.tsx
----------------------------------------
// src/components/dynamicForm/components/fieldInputs/UrlInput.tsx
import React from "react";
import { Controller, useFormContext } from "react-hook-form";
import { TextField } from "@mui/material";
import type { CommonFieldProps } from "../../types";

const UrlInput: React.FC<CommonFieldProps> = ({
  name,
  label,
  required,
  errors,
}) => {
  const { control } = useFormContext();
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { onChange, value }, fieldState: { error } }) => (
        <TextField
          value={value ?? ""}
          onChange={onChange}
          label={label}
          type="url"
          required={required}
          fullWidth
          error={!!error || !!errors?.[name]}
          helperText={
            error?.message || (errors?.[name] as { message?: string })?.message
          }
        />
      )}
    />
  );
};

export default UrlInput;


==================================================

FILE: src\components\dynamicForm\components\HeaderSection.tsx
----------------------------------------
import React from "react";
import { Box, Typography, Alert } from "@mui/material";
import FieldInput from "./fieldInputs/FieldInput";
import type { HeaderSectionProps } from "../types"; // FIXED: Removed unused imports

const HeaderSection: React.FC<HeaderSectionProps> = ({
  fields,
  baseName = "",
  entityOptions,
  register,
  watch,
  setValue,
  control,
  errors,
}) => {
  // FIXED: Updated logic to handle FieldErrors<FormValues> and avoid 'any'
  const hasHeaderErrors =
    errors &&
    Object.entries(errors)
      .filter(
        ([key]) => key !== "items" && key !== "" && typeof key === "string"
      ) // Skip items & empty; ensure string key
      .some(([, err]) => {
        if (err && typeof err === "object" && err !== null) {
          return Object.keys(err).length > 0;
        }
        return !!err;
      });

  return (
    <Box sx={{ mb: { xs: 2, md: 4 } }}>
      {" "}
      {/* Responsive margin */}
      <Typography variant="h6" sx={{ mb: 2 }}>
        سربرگ
      </Typography>
      {hasHeaderErrors && (
        <Alert severity="error" sx={{ mb: 2 }}>
          لطفاً فیلدهای الزامی سربرگ را پر کنید.
        </Alert>
      )}
      {fields.map((field) => (
        <Box key={field.id} sx={{ mb: 2 }}>
          <FieldInput
            field={field}
            baseName={baseName}
            entityOptions={entityOptions}
            register={register}
            watch={watch}
            setValue={setValue}
            control={control}
            errors={errors}
            name="" // Overridden in FieldInput
            label={field.label}
            required={field.required ?? false}
          />
        </Box>
      ))}
    </Box>
  );
};

export default HeaderSection;


==================================================

FILE: src\components\dynamicForm\components\ItemsSection.tsx
----------------------------------------
// FILE: src/components/dynamicForm/components/ItemsSection.tsx
import React from "react";
import {
  Box,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  IconButton,
  Button,
  Typography,
  Alert,
} from "@mui/material";
import { Delete as DeleteIcon, Add as AddIcon } from "@mui/icons-material";
import FieldInput from "./fieldInputs/FieldInput";
import type { ItemsSectionProps, FieldErrors, FormValues } from "../types";

const ItemsSection: React.FC<ItemsSectionProps> = ({
  fields,
  itemFields,
  onAppend,
  onRemove,
  entityOptions,
  register,
  watch,
  setValue,
  control,
  errors,
}) => {
  const hasItemsErrors =
    errors?.items &&
    Array.isArray(errors.items) &&
    errors.items.some((itemError) => {
      if (itemError && typeof itemError === "object" && itemError !== null) {
        return Object.keys(itemError).length > 0;
      }
      return false;
    });

  return (
    <Box sx={{ mb: { xs: 2, md: 4 } }}>
      <Typography variant="h6" sx={{ mb: 2 }}>
        اقلام
      </Typography>
      {hasItemsErrors && (
        <Alert severity="error" sx={{ mb: 2 }}>
          لطفاً فیلدهای الزامی اقلام را پر کنید.
        </Alert>
      )}
      <TableContainer sx={{ overflowX: "auto" }}>
        <Table stickyHeader sx={{ minWidth: "max-content" }}>
          <TableHead>
            <TableRow>
              {fields.map((field) => (
                <TableCell key={field.id}>{field.label}</TableCell>
              ))}
              <TableCell>عملیات</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {itemFields.map((itemField, index) => (
              <TableRow key={itemField.id}>
                {fields.map((field) => {
                  const itemErrors =
                    (errors?.items as FieldErrors<FormValues>[] | undefined)?.[
                      index
                    ] ?? {};
                  return (
                    <TableCell key={field.id}>
                      <FieldInput
                        field={field}
                        baseName={`items.${index}`}
                        isItem
                        entityOptions={entityOptions}
                        register={register}
                        watch={watch}
                        setValue={setValue}
                        control={control}
                        errors={itemErrors}
                        name=""
                        label={field.label}
                        required={field.required ?? false}
                      />
                    </TableCell>
                  );
                })}
                <TableCell>
                  <IconButton onClick={() => onRemove(index)}>
                    <DeleteIcon />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <Button
        startIcon={<AddIcon />}
        type="button"
        onClick={onAppend}
        fullWidth
        sx={{ mt: 2 }}
      >
        افزودن اقلام
      </Button>
    </Box>
  );
};

export default ItemsSection;


==================================================

FILE: src\components\dynamicForm\CreateRecord.tsx
----------------------------------------
import { useState, useEffect } from "react";
import {
  Box,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  CircularProgress,
  Typography,
  type AlertColor,
} from "@mui/material";
import DynamicForm from "./DynamicForm";
import { getFormTypes, createRecord } from "@/lib/appwrite"; // Changed Import
import type { FormSchema, FormType } from "@/types";

interface CreateRecordProps {
  onCancel: () => void;
  onSuccess?: () => void;
  showSnackbar: (message: string, severity?: AlertColor) => void;
}

export default function CreateRecord({
  onCancel,
  onSuccess,
  showSnackbar,
}: CreateRecordProps) {
  const [formTypes, setFormTypes] = useState<FormType[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedType, setSelectedType] = useState<string>("");
  const [selectedSchema, setSelectedSchema] = useState<FormSchema>({
    name: "",
    hasItems: false,
    headerFields: [],
    itemFields: [],
  });

  useEffect(() => {
    const fetchTypes = async () => {
      setLoading(true);
      try {
        // REPLACED: fetch("/api/form-types") -> getFormTypes()
        const types = await getFormTypes();
        setFormTypes(types as FormType[]);
      } catch {
        showSnackbar("خطا در بارگذاری انواع فرم", "error");
      } finally {
        setLoading(false);
      }
    };
    fetchTypes();
  }, [showSnackbar]);

  useEffect(() => {
    if (selectedType) {
      const type = formTypes.find((t) => t.$id === selectedType);
      setSelectedSchema(
        type?.schema ?? {
          name: "",
          hasItems: false,
          headerFields: [],
          itemFields: [],
        }
      );
    } else {
      setSelectedSchema({
        name: "",
        hasItems: false,
        headerFields: [],
        itemFields: [],
      });
    }
  }, [selectedType, formTypes]);

  const handleSubmit = async (data: object) => {
    if (!selectedType) return;

    // REPLACED: fetch("/api/records") -> createRecord()
    const result = await createRecord(selectedType, data);

    if (result.success) {
      showSnackbar("رکورد با موفقیت ایجاد شد!", "success");
      onSuccess?.();
      setSelectedType("");
    } else {
      showSnackbar("خطا در ایجاد رکورد", "error");
    }
  };

  if (loading) {
    return (
      <Box sx={{ display: "flex", justifyContent: "center", py: 8 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box sx={{ p: { xs: 1, sm: 2, md: 3 }, maxWidth: "100%" }}>
      <FormControl fullWidth sx={{ mb: 3 }}>
        <InputLabel>انتخاب نوع فرم</InputLabel>
        <Select
          value={selectedType}
          label="انتخاب نوع فرم"
          onChange={(e) => setSelectedType(e.target.value)}
        >
          <MenuItem value="">یک نوع انتخاب کنید</MenuItem>
          {formTypes.map((type) => (
            <MenuItem key={type.$id} value={type.$id}>
              {type.name}
            </MenuItem>
          ))}
        </Select>
      </FormControl>

      {selectedType ? (
        <DynamicForm
          schema={selectedSchema}
          initialData={{ header: {}, items: [] }}
          onSubmit={handleSubmit}
          onCancel={onCancel}
        />
      ) : (
        <Typography align="center" color="text.secondary">
          برای ایجاد رکورد، یک نوع فرم انتخاب کنید.
        </Typography>
      )}
    </Box>
  );
}


==================================================

FILE: src\components\dynamicForm\DynamicForm.tsx
----------------------------------------
"use client";

import React from "react";
import { Box, Button, Typography, Alert, Stack } from "@mui/material";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import { FormProvider } from "react-hook-form";
import { useDynamicForm } from "./hooks/useDynamicForm";
import { useEntityOptions } from "./hooks/useEntityOptions";
import { processFormData } from "./utils/processFormData";
import { getResetFormData } from "./utils/getResetFormData";
import HeaderSection from "./components/HeaderSection";
import ItemsSection from "./components/ItemsSection";
import type { DynamicFormProps, FormData } from "./types";

export default function DynamicForm({
  schema,
  initialData = { header: {}, items: [] },
  onSubmit,
  onCancel,
}: DynamicFormProps) {
  const { form, itemFields, append, remove, headerDefaults } = useDynamicForm(
    schema,
    initialData
  );

  const {
    register,
    handleSubmit: rhfHandleSubmit,
    watch,
    setValue,
    control,
    formState: { errors },
  } = form;

  const { entityOptions: headerEntityOptions } = useEntityOptions(
    schema.headerFields
  );
  const { entityOptions: itemEntityOptions } = useEntityOptions(
    schema.itemFields
  );

  const handleSubmit = (data: FormData) => {
    try {
      console.log("Form data before save:", data);
      const { header, items } = processFormData(data);
      onSubmit({ header, items });
      form.reset(getResetFormData(headerDefaults));
    } catch (err) {
      console.error("Form processing error:", err);
    }
  };

  const hasErrors = Object.keys(errors).length > 0;

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box
        sx={{
          p: { xs: 1, sm: 2, md: 3 },
          maxWidth: "100%",
          width: "100%",
        }}
      >
        <Typography variant="h5" sx={{ mb: 3 }}>
          فرم پویا
        </Typography>
        {hasErrors && (
          <Alert severity="error" sx={{ mb: 2 }}>
            لطفاً فیلدهای الزامی را پر کنید. خطاها در زیر نمایش داده شده‌اند.
          </Alert>
        )}
        <FormProvider {...form}>
          <form onSubmit={rhfHandleSubmit(handleSubmit)}>
            <HeaderSection
              fields={schema.headerFields}
              baseName=""
              entityOptions={headerEntityOptions}
              register={register}
              watch={watch}
              setValue={setValue}
              control={control}
              errors={errors}
            />
            {schema.hasItems && (
              <ItemsSection
                fields={schema.itemFields}
                itemFields={itemFields}
                onAppend={append}
                onRemove={remove}
                entityOptions={itemEntityOptions}
                register={register}
                watch={watch}
                setValue={setValue}
                control={control}
                errors={errors}
              />
            )}
            <Stack
              direction={{ xs: "column", sm: "row" }}
              spacing={2}
              sx={{ mt: 3, justifyContent: "flex-end" }}
            >
              <Button type="button" onClick={onCancel}>
                لغو
              </Button>
              <Button variant="contained" type="submit">
                ارسال
              </Button>
            </Stack>
          </form>
        </FormProvider>
      </Box>
    </LocalizationProvider>
  );
}


==================================================

FILE: src\components\dynamicForm\hooks\useDynamicForm.ts
----------------------------------------
import { useForm, useFieldArray } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { useMemo } from "react";
import type { Schema, FormData, ItemData } from "../types"; // FIXED: Import FormSchema instead of Schema
import { useDynamicSchema } from "./useDynamicSchema";
import { getItemDefaults } from "../utils/getItemDefaults";

export const useDynamicForm = (
  schema: Schema, // FIXED: Use Schema
  initialData?: Partial<FormData>
) => {
  const { fullSchema, headerDefaults } = useDynamicSchema(schema);

  // SIMPLIFIED: Always include items as [] or initial; schema allows it
  const defaultValues = useMemo(
    () => ({
      ...headerDefaults,
      ...(initialData?.header ?? {}),
      items: initialData?.items || [],
    }),
    [headerDefaults, initialData]
  );

  const form = useForm<FormData>({
    resolver: zodResolver(fullSchema),
    defaultValues,
  });

  // Unconditional hook; dynamic path OK with @ts-expect-error
  const {
    fields: rawItemFields,
    append: rawAppend,
    remove: rawRemove,
  } = useFieldArray({
    control: form.control,
    // @ts-expect-error Dynamic FormData causes ArrayPath<'never'>; "items" exists at runtime via schema
    name: "items" as const,
  });

  // Type explicitly
  const itemFields: { id: string }[] = useMemo(
    () => (schema.hasItems ? rawItemFields : []),
    [rawItemFields, schema.hasItems]
  );

  const itemDefaults = useMemo(() => getItemDefaults(schema), [schema]);

  const appendItem = () => {
    if (schema.hasItems) {
      rawAppend(itemDefaults as ItemData);
    }
  };

  const removeItem = (index: number) => {
    if (schema.hasItems) {
      rawRemove(index);
    }
  };

  return {
    form,
    itemFields,
    append: appendItem,
    remove: removeItem,
    headerDefaults,
  };
};


==================================================

FILE: src\components\dynamicForm\hooks\useDynamicSchema.ts
----------------------------------------
import { useMemo } from "react";

import type { Schema } from "../types";
import { buildZodShape } from "../utils/buildZodShape"; // Now supports all types
import { buildDefaults } from "../utils/buildDefaults";
import { buildFullZodSchema } from "../utils/buildFullZodSchema";

export const useDynamicSchema = (schema: Schema) => {
  // CHANGED: Pass fields directly; buildZodShape now uses raw labels
  const headerShape = useMemo(
    () => buildZodShape(schema.headerFields),
    [schema.headerFields]
  );

  const itemShape = useMemo(
    () => (schema.hasItems ? buildZodShape(schema.itemFields) : {}),
    [schema.hasItems, schema.itemFields]
  );

  const fullSchema = useMemo(
    () => buildFullZodSchema(headerShape, itemShape),
    [headerShape, itemShape]
  );

  // CHANGED: buildDefaults now uses raw labels
  const headerDefaults = useMemo(
    () => buildDefaults(schema.headerFields),
    [schema.headerFields]
  );

  return { fullSchema, headerDefaults };
};


==================================================

FILE: src\components\dynamicForm\hooks\useEntityOptions.ts
----------------------------------------
import { useState, useEffect } from "react";
import type { Field, EntityOption } from "../types";
import { getRecordsForReference } from "@/lib/appwrite";
import { mapRecordsToOptions } from "../utils/mapRecordsToOptions";
import { getEntityReferenceFields } from "../utils/getEntityReferenceFields";
import { getFormTypes } from "@/lib/appwrite";
// import { buildFieldKey } from "../utils/buildFieldKey"; // REMOVED

interface FormType {
  $id: string;
  name: string;
  schema: {
    hasItems: boolean;
    headerFields: Field[];
    itemFields: Field[];
  };
}

type Schema = FormType["schema"];

export const useEntityOptions = (fields: Field[]) => {
  const [entityOptions, setEntityOptions] = useState<{
    [key: string]: EntityOption[];
  }>({});
  const [loading, setLoading] = useState<boolean>(false); // NEW: Loading state

  useEffect(() => {
    console.log(
      "[DEBUG] useEntityOptions: Fields changed, starting fetch:",
      fields
    );

    const fetchEntities = async () => {
      if (fields.length === 0) {
        setEntityOptions({});
        setLoading(false);
        return;
      }

      setLoading(true); // NEW: Set loading

      const newOptions: { [key: string]: EntityOption[] } = {};

      let targetTypes: FormType[] = [];
      try {
        const rawTypes = await getFormTypes();
        console.log(
          "[DEBUG] useEntityOptions: Raw form types fetched:",
          rawTypes
        );
        targetTypes = rawTypes.map(
          (t: { $id: string; name: string; schema: unknown }) => ({
            $id: t.$id,
            name: t.name,
            schema: t.schema as Schema,
          })
        );
        console.log(
          "[DEBUG] useEntityOptions: Processed target types:",
          targetTypes
        );
      } catch (error) {
        console.error("Failed to fetch form types for entity options:", error);
      }

      const referenceFields = getEntityReferenceFields(fields); // Now fixed; will log inside
      console.log(
        "[DEBUG] useEntityOptions: Reference fields found:",
        referenceFields
      );

      for (const field of referenceFields) {
        try {
          console.log(
            `[DEBUG] useEntityOptions: Processing field ${field.id} (label: ${field.label}, target: ${field.targetFormType}, displayField: "${field.displayField}")`
          );

          let displayKey: string | undefined;

          if (field.displayField && field.targetFormType) {
            const targetType = targetTypes.find(
              (t) => t.$id === field.targetFormType
            );
            console.log(
              `[DEBUG] useEntityOptions: Target type for ${field.id}:`,
              targetType
            );
            if (targetType && targetType.schema) {
              const schema = targetType.schema;
              const displayFieldObj: Field | undefined =
                schema.headerFields.find(
                  (f: Field) => f.label === field.displayField
                );
              console.log(
                `[DEBUG] useEntityOptions: Display field match for "${field.displayField}":`,
                displayFieldObj
              );
              if (displayFieldObj) {
                // CHANGED: Use raw label as displayKey (with spaces)
                displayKey = displayFieldObj.label;
                console.log(
                  `[DEBUG] useEntityOptions: Computed displayKey for ${field.id}: "${displayKey}"`
                );
              } else {
                console.warn(
                  `Display field "${field.displayField}" not found in target schema for ${field.id}. Available labels:`,
                  schema.headerFields.map((f) => f.label)
                );
              }
            }
          }

          const records = await getRecordsForReference(field.targetFormType!);
          console.log(
            `[DEBUG] useEntityOptions: Records fetched for ${field.id}:`,
            records
          );

          const options = mapRecordsToOptions(records, displayKey);
          console.log(
            `[DEBUG] useEntityOptions: Mapped options for ${field.id}:`,
            options
          );

          newOptions[field.id] = options;
        } catch (error) {
          console.error(
            `Failed to fetch entities for field ${field.id}:`,
            error
          );
          newOptions[field.id] = [];
        }
      }
      console.log("[DEBUG] useEntityOptions: Final newOptions:", newOptions);
      setEntityOptions(newOptions);
    };

    fetchEntities();
    setLoading(false); // NEW: Reset loading after fetch
  }, [fields]);

  console.log(
    "[DEBUG] useEntityOptions: Returning entityOptions:",
    entityOptions
  );
  return { entityOptions, loading }; // NEW: Return loading
};


==================================================

FILE: src\components\dynamicForm\types\index.ts
----------------------------------------
// src/components/dynamicForm/types/index.ts
// Shared types and constants for form builder schema and UI labels.
// This centralizes definitions to avoid duplication and improve type safety.
import { AlertColor } from "@mui/material";
import type {
  UseFormRegister,
  UseFormWatch,
  UseFormSetValue,
  Control,
  FieldErrors,
} from "react-hook-form";

export type FieldType = // Match main.js exactly

    | "text"
    | "textarea"
    | "number"
    | "integer"
    | "decimal"
    | "email"
    | "password"
    | "url"
    | "date"
    | "datetime"
    | "time"
    | "select"
    | "multiselect"
    | "checkbox"
    | "radio"
    | "file"
    | "image"
    | "hidden"
    | "reference"
    | "boolean";

export interface Field {
  id: string;
  type: FieldType;
  label: string;
  required?: boolean;
  options?: string[];
  targetFormType?: string; // For 'reference'
  displayField?: string; // For 'reference'
  multiple?: boolean; // For 'multiselect'
}

export interface FormSchema {
  name: string;
  hasItems: boolean;
  headerFields: Field[];
  itemFields: Field[];
}

// Export Schema as alias for FormSchema for backward compatibility
export type Schema = Omit<FormSchema, "name">; // FIXED: Explicitly omit 'name' for listViewer compatibility

// FIXED: Define FormValues for RHF generics
export type FormValues = Record<string, unknown>;

// FIXED: Define AnyObject to avoid 'any' usage
export type AnyObject = Record<string, unknown>;

// FIXED: Re-export FieldErrors from react-hook-form
export type { FieldErrors };

// Full form type from DB (extends schema for storage)
export interface FormType {
  $id: string;
  name: string;
  schema: FormSchema;
}

// Persian labels for field types (used in selects and chips)
export const FIELD_TYPES: { [key in FieldType]: string } = {
  text: "فیلد متنی",
  textarea: "فیلد متنی چندخطی",
  number: "فیلد عددی",
  integer: "عدد صحیح",
  decimal: "عدد اعشاری",
  email: "ایمیل",
  password: "رمز عبور",
  url: "آدرس وب",
  date: "تاریخ",
  datetime: "تاریخ و زمان",
  time: "زمان",
  select: "لیست کشویی",
  multiselect: "چند انتخابی",
  checkbox: "چک‌باکس",
  radio: "دکمه رادیویی",
  file: "فایل",
  image: "تصویر",
  hidden: "مخفی",
  reference: "مرجع موجودیت",
  boolean: "بولی",
};

// Short Persian chips for field types
export const TYPE_TO_PERSIAN: { [key in FieldType]: string } = {
  text: "متنی",
  textarea: "متنی چندخطی",
  number: "عددی",
  integer: "عدد صحیح",
  decimal: "اعشاری",
  email: "ایمیل",
  password: "رمز",
  url: "وب",
  date: "تاریخ",
  datetime: "تاریخ/زمان",
  time: "زمان",
  select: "انتخابی",
  multiselect: "چندانتخابی",
  checkbox: "چک‌باکس",
  radio: "رادیویی",
  file: "فایل",
  image: "تصویر",
  hidden: "مخفی",
  reference: "مرجع",
  boolean: "بولی",
};

export interface FormTypeManagerProps {
  onNewSave: (schema: FormSchema) => Promise<void>;
  onCancel: () => void;
}

export interface FormTypeBuilderProps {
  initialSchema: FormSchema;
  isEditing?: boolean;
  onSave: (schema: FormSchema) => Promise<void>;
  onDelete?: () => void;
  onCancel?: () => void;
}

export interface SnackbarState {
  open: boolean;
  message: string;
  severity: AlertColor;
}

export interface SelectOptionsDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (options: string[]) => void;
  initialOptions?: string[];
}

export interface FieldLabelDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (label: string, required: boolean) => void;
  fieldType: string;
}

export interface EntityRefDialogProps {
  open: boolean;
  onClose: () => void;
  onSelect: (target: string) => void;
}

export interface DisplayFieldDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (displayField: string) => void;
  targetFormType?: string;
}

export interface SchemaDisplayProps {
  formName: string;
  onFormNameChange: (name: string) => void;
  hasItems: boolean;
  onHasItemsChange: (hasItems: boolean) => void;
  headerFields: Field[];
  itemFields: Field[];
  onDeleteField: (id: string, isHeader: boolean) => void;
}

export interface ManagerTypeSelectorProps {
  selectedType: string;
  onTypeChange: (type: string) => void; // Explicitly string (no union)
}

export interface FieldTypeSelectorProps {
  selectedType: string; // Keeps as string (union of literals assignable)
  onTypeChange: (type: string) => void;
  onAddToHeader: () => void;
  onAddToItems: () => void;
  hasItems: boolean;
}

export interface BuilderActionsProps {
  formName: string;
  hasItems: boolean;
  headerFields: Field[];
  itemFields: Field[];
  isEditing: boolean;
  onSave: (schema: FormSchema) => Promise<void>;
  onDelete?: () => void;
  onCancel?: () => void;
}

export interface RawFormType {
  $id: string;
  name: string;
  schema: unknown; // Start loose, cast later
}

export interface UseFormTypeActionsProps {
  selectedType: string;
  setCurrentSchema: (schema: FormSchema) => void;
  setSelectedType: (type: string) => void;
  onNewSave: (schema: FormSchema) => Promise<void>;
}

export interface UseFormSchemaProps {
  initialSchema: FormSchema;
}

export interface UseFieldAdditionProps {
  selectedType: keyof typeof FIELD_TYPES;
  setSelectedType: (type: keyof typeof FIELD_TYPES) => void;
  addField: (
    zone: "header" | "items",
    type: Field["type"],
    label: string,
    options?: string[],
    targetId?: string,
    required?: boolean,
    displayField?: string // NEW
  ) => void;
}

export interface FieldsListProps {
  fields: Field[];
  isHeader: boolean;
  onDeleteField: (id: string, isHeader: boolean) => void;
  formTypes: FormType[];
}

export interface FieldChipsProps {
  field: Field;
  getReferenceName: (targetId: string) => string;
}

// In UseFieldAdditionProps

// FIXED: Updated CommonFieldProps to include register for input components
export interface CommonFieldProps {
  register?: UseFormRegister<FormValues>;
  name: string;
  label: string;
  required?: boolean;
  errors?: FieldErrors<FormValues>;
}

export interface SelectFieldProps extends CommonFieldProps {
  options: string[];
}

export interface EntityFieldProps extends CommonFieldProps {
  options: EntityOption[];
  field: Field;
}

export interface EntityOption {
  $id: string;
  name: string;
  data: object;
}

export interface FieldInputProps {
  field: Field;
  baseName?: string;
  isItem?: boolean;
  entityOptions: { [key: string]: EntityOption[] };
  register?: UseFormRegister<FormValues>;
  watch?: UseFormWatch<FormValues>;
  setValue?: UseFormSetValue<FormValues>;
  control?: Control<FormValues>;
  errors?: FieldErrors<FormValues>;
  name: string;
  label: string;
  required: boolean;
}

export interface HeaderSectionProps {
  fields: Field[];
  baseName?: string;
  entityOptions: { [key: string]: EntityOption[] };
  register?: UseFormRegister<FormValues>;
  watch?: UseFormWatch<FormValues>;
  setValue?: UseFormSetValue<FormValues>;
  control?: Control<FormValues>;
  errors?: FieldErrors<FormValues>;
}

export interface ItemsSectionProps {
  fields: Field[];
  itemFields: { id: string }[];
  onAppend: () => void;
  onRemove: (index: number) => void;
  entityOptions: { [key: string]: EntityOption[] };
  register?: UseFormRegister<FormValues>;
  watch?: UseFormWatch<FormValues>;
  setValue?: UseFormSetValue<FormValues>;
  control?: Control<FormValues>;
  errors?: FieldErrors<FormValues>;
}

export interface DynamicFormProps {
  schema: Schema; // FIXED: Use Schema (omits 'name') instead of FormSchema
  initialData?: {
    header: Record<string, unknown>;
    items: Array<Record<string, unknown>>;
  };
  onSubmit: (data: object) => void;
  onCancel: () => void;
}
export interface FormData {
  [key: string]: unknown;
  items?: Array<Record<string, unknown>>;
}

export interface ItemData {
  [key: string]: unknown;
}

export interface CreateRecordProps {
  onCancel: () => void;
  onSuccess?: () => void; // New: Callback for parent on successful save
  showSnackbar: (message: string, severity?: AlertColor) => void; // NEW: From parent
}


==================================================

FILE: src\components\dynamicForm\utils\buildDefaults.ts
----------------------------------------
import type { Field } from "../types";
// import { buildFieldKey } from "./buildFieldKey"; // REMOVED: No longer needed
import { getFieldDefaultValue } from "./getFieldDefaultValue";

export const buildDefaults = (fields: Field[]): Record<string, unknown> =>
  Object.fromEntries(
    fields.map((field) => [
      // CHANGED: Use raw field.label as key (with spaces)
      field.label,
      getFieldDefaultValue(field),
    ])
  );


==================================================

FILE: src\components\dynamicForm\utils\buildFieldKey.ts
----------------------------------------
export const buildFieldKey = (label: string): string =>
  label.toLowerCase().replace(/\s+/g, "_");


==================================================

FILE: src\components\dynamicForm\utils\buildFullZodSchema.ts
----------------------------------------
import { z } from "zod";

export function buildFullZodSchema(
  headerShape: Record<string, z.ZodType<unknown>>,
  itemShape: Record<string, z.ZodType<unknown>>
) {
  // FIXED: Always optional array (allows [] or undefined); no strict undefined
  // Use hasItems for UI only; validation flexible to match form state
  const itemsSchema = z.array(z.object(itemShape)).optional();

  return z.object({
    ...headerShape,
    items: itemsSchema,
  });
}


==================================================

FILE: src\components\dynamicForm\utils\buildZodShape.ts
----------------------------------------
import { z } from "zod";
import type { Field } from "../types";
// import { buildFieldKey } from "./buildFieldKey"; // REMOVED

export const buildZodShape = (
  fields: Field[]
): { [key: string]: z.ZodTypeAny } => {
  const shape: { [key: string]: z.ZodTypeAny } = {};
  fields.forEach((field) => {
    // CHANGED: Use raw field.label as key (with spaces); Zod supports string keys with spaces
    const key = field.label;
    if (!key || key === "") {
      console.warn(`Skipping field with empty label: ${field.id}`);
      return;
    }
    let schema: z.ZodTypeAny;
    switch (field.type) {
      case "text":
      case "textarea":
      case "select":
      case "reference":
        schema = field.required
          ? z.string().min(1, `${field.label} الزامی است.`)
          : z.string().optional();
        break;
      case "number":
      case "integer":
      case "decimal":
        schema = field.required
          ? z.number().min(0, `${field.label} باید عددی معتبر باشد.`)
          : z.number().optional();
        break;
      case "email":
        schema = field.required
          ? z.string().email(`${field.label} ایمیل معتبر نیست.`).min(1)
          : z.string().email().optional();
        break;
      case "url":
        schema = field.required
          ? z.string().url(`${field.label} URL معتبر نیست.`).min(1)
          : z.string().url().optional();
        break;
      case "password":
        schema = field.required
          ? z.string().min(1, `${field.label} الزامی است.`)
          : z.string().optional();
        break;
      case "date":
        schema = field.required
          ? z
              .string()
              .pipe(z.coerce.date())
              .refine((d) => !isNaN(d.getTime()), {
                message: `${field.label} تاریخ معتبری نیست.`,
              })
          : z.string().optional();
        break;
      case "datetime":
        schema = field.required
          ? z
              .string()
              .pipe(z.coerce.date())
              .refine((d) => !isNaN(d.getTime()), {
                message: `${field.label} تاریخ/زمان معتبر نیست.`,
              })
          : z.string().optional();
        break;
      case "time":
        schema = field.required
          ? z.string().min(1, `${field.label} زمان معتبری است.`)
          : z.string().optional();
        break;
      case "multiselect":
        schema = field.required
          ? z.array(z.string()).min(1, `${field.label} حداقل یکی انتخاب کنید.`)
          : z.array(z.string()).optional();
        break;
      case "checkbox":
      case "radio":
        schema = field.required ? z.boolean() : z.boolean().optional();
        break;
      case "file":
      case "image":
        schema = field.required
          ? z.string().min(1, `${field.label} فایل الزامی است.`)
          : z.string().optional();
        break;
      case "hidden":
        schema = z.any().optional(); // No validation
        break;
      default:
        schema = z.any();
    }
    shape[key] = schema;
  });
  return shape;
};


==================================================

FILE: src\components\dynamicForm\utils\formUtils.ts
----------------------------------------
// src/components/dynamicForm/utils/formUtils.ts
// utils/formUtils.ts
import { z } from "zod";
import type { Field } from "../types"; // Adjust path as needed

// Utility: Standardize field keys (e.g., "Customer Name" -> "customer_name")
export const buildFieldKey = (label: string): string =>
  label.toLowerCase().replace(/\s+/g, "_");

// Utility: Get default value for a field based on type
export const getFieldDefaultValue = (field: Field): unknown => {
  switch (field.type) {
    case "number":
      return 0;
    case "checkbox":
      return false;
    case "date":
      return "";
    default:
      return "";
  }
};

// Utility: Build Zod schema shape from fields
export const buildZodShape = (
  fields: Field[]
): { [key: string]: z.ZodTypeAny } => {
  const shape: { [key: string]: z.ZodTypeAny } = {};
  fields.forEach((field) => {
    const key = buildFieldKey(field.label);
    let schema: z.ZodTypeAny;
    switch (field.type) {
      case "text":
      case "select":
      case "reference":
        schema = field.required ? z.string().min(1) : z.string().optional();
        break;
      case "number":
        schema = field.required ? z.number().min(0) : z.number().optional();
        break;
      case "date":
        schema = field.required
          ? z.string().pipe(z.coerce.date())
          : z.string().optional();
        break;
      case "checkbox":
        schema = field.required ? z.boolean() : z.boolean().optional();
        break;
      default:
        schema = z.any();
    }
    shape[key] = schema;
  });
  return shape;
};

// Utility: Build defaults object from fields
export const buildDefaults = (fields: Field[]): Record<string, unknown> =>
  Object.fromEntries(
    fields.map((field) => [
      buildFieldKey(field.label),
      getFieldDefaultValue(field),
    ])
  );


==================================================

FILE: src\components\dynamicForm\utils\getEntityReferenceFields.ts
----------------------------------------
// src/components/dynamicForm/utils/getEntityReferenceFields.ts
import type { Field } from "../types";

export function getEntityReferenceFields(fields: Field[]): Field[] {
  console.log(
    "[DEBUG] getEntityReferenceFields: Raw fields:",
    fields.map((f) => ({ id: f.id, type: f.type, target: f.targetFormType }))
  ); // Log raw for debug

  const references = fields.filter((field) => {
    const isRef = field.type === "reference" && !!field.targetFormType; // FIXED: "reference" not "entity_reference"
    console.log(
      "[DEBUG] getEntityReferenceFields: Field check:",
      field.id,
      field.type,
      "isRef:",
      isRef
    ); // Per-field log
    return isRef;
  });

  console.log(
    "[DEBUG] getEntityReferenceFields: Filtered references:",
    references
  ); // Final log
  return references;
}


==================================================

FILE: src\components\dynamicForm\utils\getFieldDefaultValue.ts
----------------------------------------
// src/components/DynamicForm/utils/getFieldDefaultValue.ts
import type { Field } from "../types";

export const getFieldDefaultValue = (field: Field): unknown => {
  switch (field.type) {
    case "number":
      return 0;
    case "checkbox":
      return false;
    case "date":
      return "";
    default:
      return "";
  }
};


==================================================

FILE: src\components\dynamicForm\utils\getItemDefaults.ts
----------------------------------------
// src/hooks/utils/getItemDefaults.ts
import { buildDefaults } from "./buildDefaults"; // Adjust path if needed based on your structure
import type { Schema } from "../types";

export function getItemDefaults(schema: Schema) {
  return buildDefaults(schema.itemFields);
}


==================================================

FILE: src\components\dynamicForm\utils\getResetFormData.ts
----------------------------------------
// src/components/DynamicForm/utils/getResetFormData.ts
export function getResetFormData(
  headerDefaults: Record<string, unknown>
): Record<string, unknown> {
  return { ...headerDefaults, items: [] };
}


==================================================

FILE: src\components\dynamicForm\utils\mapRecordsToOptions.ts
----------------------------------------
import type { EntityOption } from "../types";

interface AppwriteRecord {
  $id: string;
  data: {
    header?: Record<string, unknown>;
    items?: Array<Record<string, unknown>>;
  };
}

export function mapRecordsToOptions(
  records: AppwriteRecord[],
  displayKey?: string // CHANGED: Now raw label with spaces
): EntityOption[] {
  return records.map((r) => {
    const header = r.data?.header || {};

    // CHANGED: Use raw displayKey (with spaces) for header access
    const displayName = displayKey
      ? header[displayKey] ?? header.name ?? r.$id // Chain ?? for safe fallback
      : header.name ?? r.$id;

    return {
      $id: r.$id,
      name: String(displayName), // FIXED: Always string; no undefined
      data: {
        header: header,
        ...(r.data.items && { items: r.data.items }), // Preserve items if they exist
      },
    };
  });
}


==================================================

FILE: src\components\dynamicForm\utils\processFormData.ts
----------------------------------------
import type { ItemData } from "../types";

export function processFormData(data: Record<string, unknown>): {
  header: Record<string, unknown>;
  items: ItemData[];
} {
  const headerData = { ...data };

  // FIXED: Extract items if present (even empty []); default to [] if missing/undefined
  const items =
    "items" in headerData ? (headerData.items as ItemData[]) || [] : [];
  delete headerData.items;

  return {
    header: headerData,
    items,
  };
}


==================================================

FILE: src\components\formBuilder\components\BuilderActions.tsx
----------------------------------------
// src/components/formBuilder/components/BuilderActions.tsx (Uniform full widths for button container)
"use client";

import React from "react";
import { Box, Button } from "@mui/material";
import { BuilderActionsProps } from "../types/index";
import { buildSchema } from "../utils/utils";

export default function BuilderActions({
  formName,
  hasItems,
  headerFields,
  itemFields,
  isEditing,
  onSave,
  onDelete,
  onCancel,
}: BuilderActionsProps) {
  const handleSave = async () => {
    if (!formName.trim()) {
      alert("نام فرم الزامی است!");
      return;
    }
    const schema = buildSchema(formName, hasItems, headerFields, itemFields);
    await onSave(schema);
  };

  return (
    <Box
      sx={{
        mt: 0.5,
        display: "flex",
        justifyContent: "center",
        gap: 0.5,
        width: "100%", // FIXED: Uniform full width for container
      }}
    >
      <Button
        onClick={onCancel}
        sx={{
          minWidth: { xs: 60, sm: 80 },
          fontSize: { xs: "0.75rem", sm: "0.875rem" },
          flex: 1, // FIXED: Equal flex to make uniform width
          maxWidth: "150px", // FIXED: Cap max width for uniformity
        }}
      >
        لغو
      </Button>
      {isEditing && onDelete && (
        <Button
          onClick={onDelete}
          color="error"
          sx={{
            minWidth: { xs: 60, sm: 80 },
            fontSize: { xs: "0.75rem", sm: "0.875rem" },
            flex: 1, // FIXED: Equal flex
            maxWidth: "150px",
          }}
        >
          حذف
        </Button>
      )}
      <Button
        variant="contained"
        onClick={handleSave}
        disabled={!formName.trim()}
        sx={{
          minWidth: { xs: 100, sm: 120 },
          fontSize: { xs: "0.75rem", sm: "0.875rem" },
          flex: 1, // FIXED: Equal flex
          maxWidth: "150px",
        }}
      >
        {isEditing ? "ذخیره تغییرات" : "ذخیره نوع فرم"}
      </Button>
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\components\CustomAccordion.tsx
----------------------------------------
// src/components/formBuilder/components/CustomAccordion.tsx (Reduced border radius for less convexity)
"use client";

import React, { useState } from "react";
import { Box, Typography, IconButton, Collapse } from "@mui/material";
import {
  ExpandMore as ExpandMoreIcon,
  ExpandLess as ExpandLessIcon,
} from "@mui/icons-material";

interface CustomAccordionProps {
  title: string;
  children: React.ReactNode;
  defaultExpanded?: boolean;
  sx?: object;
}

export default function CustomAccordion({
  title,
  children,
  defaultExpanded = true,
  sx,
}: CustomAccordionProps) {
  const [expanded, setExpanded] = useState(defaultExpanded);

  const handleToggle = () => {
    setExpanded(!expanded);
  };

  return (
    <Box
      sx={{
        width: "100%",
        borderRadius: 4, // FIXED: Reduced from 6 to 4 for less convexity
        overflow: "hidden",
        backgroundColor: "rgba(255, 255, 255, 0.05)",
        ...sx,
      }}
    >
      {/* Summary */}
      <Box
        onClick={handleToggle}
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          p: 2,
          cursor: "pointer",
          backgroundColor: "rgba(0, 0, 0, 0.1)",
          "&:hover": {
            backgroundColor: "rgba(0, 0, 0, 0.15)",
          },
        }}
      >
        <Typography
          variant="h6"
          sx={{
            fontSize: { xs: "1.25rem", sm: "1.5rem" },
            flexGrow: 1,
          }}
        >
          {title}
        </Typography>
        <IconButton size="small">
          {expanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        </IconButton>
      </Box>

      {/* Details - Collapsible */}
      <Collapse in={expanded} timeout="auto" unmountOnExit>
        <Box sx={{ p: 2 }}>{children}</Box>
      </Collapse>
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\components\FieldChips.tsx
----------------------------------------
// src/components/formBuilder/components/FieldChips.tsx (Reduced height for less tall chips)
import React from "react";
import { Box, Chip } from "@mui/material";
import type { Field } from "../types";
import { TYPE_TO_PERSIAN } from "../types";

interface FieldChipsProps {
  field: Field;
  getReferenceName: (targetId: string) => string;
}

export default function FieldChips({
  field,
  getReferenceName,
}: FieldChipsProps) {
  return (
    <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5, mt: 0.5 }}>
      <Chip
        label={TYPE_TO_PERSIAN[field.type]}
        sx={{
          fontSize: { xs: "0.65rem", sm: "0.875rem" },
          height: { xs: 20, sm: 26 }, // FIXED: Reduced height from 24/32 to 20/26 for less tall
          "& .MuiChip-label": { px: { xs: 0.5, sm: 1 } },
          minWidth: "70px",
        }}
        color="primary"
      />
      {field.required && (
        <Chip
          label="الزامی"
          sx={{
            fontSize: { xs: "0.65rem", sm: "0.875rem" },
            height: { xs: 20, sm: 26 }, // FIXED: Reduced height
            "& .MuiChip-label": { px: { xs: 0.5, sm: 1 } },
            minWidth: "70px",
          }}
          color="error"
        />
      )}
      {field.options && field.options.length > 0 && (
        <Chip
          label={`${field.options.length} گزینه`}
          sx={{
            fontSize: { xs: "0.65rem", sm: "0.875rem" },
            height: { xs: 20, sm: 26 }, // FIXED: Reduced height
            "& .MuiChip-label": { px: { xs: 0.5, sm: 1 } },
            minWidth: "70px",
          }}
          color="secondary"
        />
      )}
      {field.targetFormType && (
        <Chip
          label={`مرجع: ${getReferenceName(field.targetFormType)}`}
          sx={{
            fontSize: { xs: "0.65rem", sm: "0.875rem" },
            height: { xs: 20, sm: 26 }, // FIXED: Reduced height
            "& .MuiChip-label": { px: { xs: 0.5, sm: 1 } },
            minWidth: "120px",
          }}
          color="info"
        />
      )}
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\components\FieldsList.tsx
----------------------------------------
// src/components/formBuilder/components/FieldsList.tsx (Reduced border radius for less convexity)
import React from "react";
import { List, ListItem, Box, Typography, IconButton } from "@mui/material";
import { Delete as DeleteIcon } from "@mui/icons-material";
import type { FieldsListProps } from "../types";
import { getFieldDisplayLabel } from "../utils/getFieldDisplayLabel";
import FieldChips from "./FieldChips";

export default function FieldsList({
  fields,
  isHeader,
  onDeleteField,
  formTypes,
}: FieldsListProps) {
  const getReferenceName = (targetId: string) => {
    const target = formTypes.find((type) => type.$id === targetId);
    return target ? target.name : "نامشخص";
  };

  return (
    <List sx={{ p: 0, width: "100%" }}>
      {fields.map((field) => (
        <ListItem
          key={field.id}
          sx={{
            py: 2,
            flexDirection: "row",
            alignItems: "flex-start",
            width: "100%",
            borderRadius: 4, // FIXED: Reduced to 4px for less convexity
            transition: "background-color 0.3s ease",
            "&:hover": {
              backgroundColor: "rgba(255, 255, 255, 0.1)",
            },
            mb: 1,
          }}
        >
          <Box
            sx={{
              flexGrow: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
            }}
          >
            <Typography
              variant="subtitle1"
              sx={{
                mb: 1,
                fontWeight: "bold",
                fontSize: "1.1rem",
                flexShrink: 0,
                width: "100%",
              }}
            >
              {getFieldDisplayLabel(field)}
            </Typography>
            <Box
              sx={{
                display: "flex",
                justifyContent: "flex-start",
                width: "100%",
              }}
            >
              <FieldChips field={field} getReferenceName={getReferenceName} />
            </Box>
          </Box>
          <IconButton
            onClick={() => onDeleteField(field.id, isHeader)}
            size="small"
            sx={{ ml: 1, mt: 0.5 }}
          >
            <DeleteIcon />
          </IconButton>
        </ListItem>
      ))}
    </List>
  );
}


==================================================

FILE: src\components\formBuilder\components\FieldTypeSelector.tsx
----------------------------------------
// src/components/formBuilder/components/FieldTypeSelector.tsx (Increased top/bottom spacing for buttons)
import React from "react";
import {
  Box,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
  Typography,
  Divider,
} from "@mui/material";
import { FIELD_TYPES, FieldTypeSelectorProps } from "../types/index";

export default function FieldTypeSelector({
  selectedType,
  onTypeChange,
  onAddToHeader,
  onAddToItems,
  hasItems,
}: FieldTypeSelectorProps) {
  return (
    <Box
      sx={{
        width: "100%",
        p: 0.5,
        mx: "auto",
      }}
    >
      <Typography variant="h6" sx={{ textAlign: "center", width: "100%" }}>
        افزودن فیلد
      </Typography>
      <Divider sx={{ my: 0.5, width: "100%" }} />
      <FormControl fullWidth sx={{ mb: 2, width: "100%" }}>
        {" "}
        {/* FIXED: Increased mb from 1 to 2 for more top space before buttons */}
        <InputLabel>نوع فیلد</InputLabel>
        <Select
          value={selectedType}
          label="نوع فیلد"
          onChange={(e) =>
            onTypeChange(e.target.value as keyof typeof FIELD_TYPES)
          }
          fullWidth
        >
          {Object.entries(FIELD_TYPES).map(([key, label]) => (
            <MenuItem key={key} value={key}>
              {label}
            </MenuItem>
          ))}
        </Select>
      </FormControl>
      <Box
        sx={{
          display: "flex",
          flexDirection: "column",
          gap: 0.5,
          width: "100%",
          mb: 2,
        }}
      >
        {" "}
        {/* FIXED: Added mb: 2 for more bottom space after buttons */}
        <Button
          variant="outlined"
          onClick={onAddToHeader}
          fullWidth
          sx={{ width: "100%" }}
        >
          افزودن به سربرگ
        </Button>
        <Button
          variant="outlined"
          onClick={onAddToItems}
          disabled={!hasItems}
          fullWidth
          sx={{ width: "100%" }}
        >
          افزودن به اقلام
        </Button>
      </Box>
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\components\ManagerTypeSelector.tsx
----------------------------------------
// FILE: src/components/formBuilder/components/ManagerTypeSelector.tsx
"use client";

import React from "react";
import { Box, FormControl, InputLabel, Select, MenuItem } from "@mui/material";
import type { FormType, ManagerTypeSelectorProps } from "../types";

interface ExtendedProps extends ManagerTypeSelectorProps {
  formTypes: FormType[];
}

export default function ManagerTypeSelector({
  selectedType,
  onTypeChange,
  formTypes,
}: ExtendedProps) {
  return (
    <Box
      sx={{
        p: 0.5,
        width: "100%",
        mx: "auto",
      }}
    >
      <FormControl fullWidth sx={{ mb: 0.5, width: "100%" }}>
        <InputLabel>نوع فرم</InputLabel>
        <Select
          value={selectedType}
          label="نوع فرم"
          onChange={(e) => onTypeChange(e.target.value as string)}
          fullWidth
        >
          <MenuItem value="new">نوع فرم جدید</MenuItem>
          {formTypes.map((type: FormType) => (
            <MenuItem key={type.$id} value={type.$id}>
              {type.name}
            </MenuItem>
          ))}
        </Select>
      </FormControl>
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\components\managetypeselectortest.tsx
----------------------------------------
// src/components/formBuilder/components/ManagerTypeSelector.tsx (Uniform full widths)
"use client";

import React from "react";
import { Box, FormControl, InputLabel, Select, MenuItem } from "@mui/material";
import { FormType, ManagerTypeSelectorProps } from "../types/index";
import { useFormTypes } from "../hooks/useFormTypes";

export default function ManagerTypeSelector({
  selectedType,
  onTypeChange,
}: ManagerTypeSelectorProps) {
  const { formTypes, loading } = useFormTypes();

  return (
    <Box
      sx={{
        p: 0.5,
        width: "100%", // FIXED: Uniform full width
        mx: "auto",
      }}
    >
      <FormControl fullWidth sx={{ mb: 0.5, width: "100%" }}>
        {" "}
        {/* FIXED: Explicit full width */}
        <InputLabel>نوع فرم</InputLabel>
        <Select
          value={selectedType}
          label="نوع فرم"
          onChange={(e) => onTypeChange(e.target.value as string)}
          disabled={loading}
          fullWidth // FIXED: Ensure select is full width
        >
          <MenuItem value="new">نوع فرم جدید</MenuItem>
          {formTypes.map((type: FormType) => (
            <MenuItem key={type.$id} value={type.$id}>
              {type.name}
            </MenuItem>
          ))}
        </Select>
      </FormControl>
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\components\NotificationSnackbar.tsx
----------------------------------------
"use client";

import React from "react";
import { Snackbar, Alert } from "@mui/material";
import { useSnackbar } from "../hooks/useSnackbar";

export default function NotificationSnackbar() {
  const { snackbar, close } = useSnackbar();

  return (
    <Snackbar
      open={snackbar.open}
      autoHideDuration={6000}
      onClose={close}
      anchorOrigin={{ vertical: "bottom", horizontal: "left" }}
    >
      <Alert
        onClose={close}
        severity={snackbar.severity}
        variant="filled"
        sx={{ width: "100%" }}
      >
        {snackbar.message}
      </Alert>
    </Snackbar>
  );
}


==================================================

FILE: src\components\formBuilder\components\SchemaDisplay.tsx
----------------------------------------
// src/components/formBuilder/components/SchemaDisplay.tsx (Fixed unused useState import)
"use client";

import React from "react"; // FIXED: Removed unused { useState }
import { useFormTypes } from "../hooks/useFormTypes";
import { Box, TextField, FormControlLabel, Switch } from "@mui/material";
import type { SchemaDisplayProps } from "../types";
import FieldsList from "./FieldsList";
import CustomAccordion from "./CustomAccordion";

export default function SchemaDisplay({
  formName,
  onFormNameChange,
  hasItems,
  onHasItemsChange,
  headerFields,
  itemFields,
  onDeleteField,
}: SchemaDisplayProps) {
  const { formTypes } = useFormTypes();

  return (
    <Box
      sx={{
        p: 0.5,
        width: "100%",
        mx: "auto",
      }}
    >
      <TextField
        label="نام نوع فرم (الزامی)"
        value={formName}
        onChange={(e) => onFormNameChange(e.target.value)}
        fullWidth
        required
        sx={{ mb: 1, width: "100%" }}
      />

      <FormControlLabel
        control={
          <Switch
            checked={hasItems}
            onChange={(e) => onHasItemsChange(e.target.checked)}
          />
        }
        label="دارای جدول اقلام؟"
        sx={{ mb: 1, justifyContent: "flex-start", width: "100%" }}
      />

      {/* Header Fields - Custom Collapsible */}
      <CustomAccordion
        title="فیلدهای سربرگ"
        defaultExpanded={true}
        sx={{ mb: 1 }}
      >
        <FieldsList
          fields={headerFields}
          isHeader={true}
          onDeleteField={onDeleteField}
          formTypes={formTypes}
        />
      </CustomAccordion>

      {/* Items Fields - Conditional and Custom Collapsible */}
      {hasItems && (
        <CustomAccordion title="فیلدهای اقلام" defaultExpanded={true}>
          <FieldsList
            fields={itemFields}
            isHeader={false}
            onDeleteField={onDeleteField}
            formTypes={formTypes}
          />
        </CustomAccordion>
      )}
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\dialogs\DisplayFieldDialog.tsx
----------------------------------------
// src/components/formBuilder/dialogs/DisplayFieldDialog.tsx (Updated to forward sx)
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  FormControlLabel,
  Checkbox,
  Button,
  List,
  ListItem,
  Typography,
} from "@mui/material";
import { getFormTypes } from "@/lib/appwrite";
import type { Field, FormSchema, DisplayFieldDialogProps } from "../types";

export default function DisplayFieldDialog({
  open,
  onClose,
  onConfirm,
  targetFormType,
  sx, // FIXED: Accept sx prop
}: DisplayFieldDialogProps) {
  const [selectedDisplayField, setSelectedDisplayField] = useState<string>("");
  const [targetFields, setTargetFields] = useState<Field[]>([]);

  useEffect(() => {
    if (!open || !targetFormType) return;

    getFormTypes()
      .then((types) => {
        const targetType = types.find((t) => t.$id === targetFormType);
        if (!targetType || !targetType.schema) {
          console.warn(
            "Target form not found or schema missing:",
            targetFormType
          );
          return;
        }

        const schema = targetType.schema as FormSchema;
        const headerFields = schema.headerFields || [];

        // Preferred: text, select, number, date
        let displayCandidates = headerFields.filter((f: Field) =>
          ["text", "select", "number", "date"].includes(f.type)
        );

        // Fallback: If none, use first field (even checkbox)
        if (displayCandidates.length === 0 && headerFields.length > 0) {
          displayCandidates = [headerFields[0]];
        }

        setTargetFields(displayCandidates);

        // Auto-select first
        if (displayCandidates.length > 0) {
          setSelectedDisplayField(displayCandidates[0].label);
        }
      })
      .catch((err) => {
        console.error("Failed to load form types:", err);
      });
  }, [open, targetFormType]);

  const handleConfirm = () => {
    if (selectedDisplayField) {
      onConfirm(selectedDisplayField);
      onClose();
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth sx={sx}>
      {" "}
      {/* FIXED: Forward sx to Dialog */}
      <DialogTitle>انتخاب فیلد نمایش برای مرجع</DialogTitle>
      <DialogContent>
        <FormControl fullWidth sx={{ mt: 2 }}>
          {targetFields.length > 0 ? (
            <List>
              {targetFields.map((fld) => (
                <ListItem key={fld.id} disablePadding>
                  <FormControlLabel
                    control={
                      <Checkbox
                        checked={selectedDisplayField === fld.label}
                        onChange={() => setSelectedDisplayField(fld.label)}
                      />
                    }
                    label={fld.label}
                    sx={{ width: "100%" }}
                  />
                </ListItem>
              ))}
            </List>
          ) : (
            <Typography color="error" sx={{ mt: 2 }}>
              هیچ فیلدی در فرم هدف یافت نشد.
            </Typography>
          )}
        </FormControl>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>لغو</Button>
        <Button
          onClick={handleConfirm}
          disabled={!selectedDisplayField}
          variant="contained"
        >
          تأیید
        </Button>
      </DialogActions>
    </Dialog>
  );
}


==================================================

FILE: src\components\formBuilder\dialogs\EntityRefDialog.tsx
----------------------------------------
// src/components/formBuilder/dialogs/EntityRefDialog.tsx (Updated to forward sx)
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Button,
} from "@mui/material";
import { getFormTypes } from "@/lib/appwrite";
import type { EntityRefDialogProps } from "../types/index";

export default function EntityRefDialog({
  open,
  onClose,
  onSelect,
  sx, // FIXED: Accept sx prop
}: EntityRefDialogProps) {
  const [formTypes, setFormTypes] = useState<{ $id: string; name: string }[]>(
    []
  );
  const [selected, setSelected] = useState("");

  // Reset selected state and fetch form types when dialog opens
  useEffect(() => {
    if (open) {
      setSelected(""); // Clear previous selection
      getFormTypes().then((types) => {
        setFormTypes(types);
      });
    }
  }, [open]);

  const handleSelect = () => {
    if (selected) {
      onSelect(selected);
      onClose(); // Close after selection
    }
  };

  return (
    <Dialog open={open} onClose={onClose} sx={sx}>
      {" "}
      {/* FIXED: Forward sx to Dialog; removed maxWidth for consistency */}
      <DialogTitle>انتخاب نوع فرم هدف برای مرجع</DialogTitle>
      <DialogContent>
        <FormControl fullWidth sx={{ mt: 2 }}>
          <InputLabel>نوع هدف</InputLabel>
          <Select
            value={selected}
            label="نوع هدف"
            onChange={(e) => setSelected(e.target.value as string)}
          >
            {formTypes.map((type) => (
              <MenuItem key={type.$id} value={type.$id}>
                {type.name}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>لغو</Button>
        <Button onClick={handleSelect} disabled={!selected}>
          انتخاب
        </Button>
      </DialogActions>
    </Dialog>
  );
}


==================================================

FILE: src\components\formBuilder\dialogs\FieldLabelDialog.tsx
----------------------------------------
// src/components/formBuilder/dialogs/FieldLabelDialog.tsx (Updated to forward sx)
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Button,
  FormControlLabel,
  Checkbox,
} from "@mui/material";
import { FIELD_TYPES, FieldLabelDialogProps } from "../types/index"; // Import for dynamic label

export default function FieldLabelDialog({
  open,
  onClose,
  onConfirm,
  fieldType,
  sx, // FIXED: Accept sx prop
}: FieldLabelDialogProps) {
  const [label, setLabel] = useState("");
  const [required, setRequired] = useState(false);

  // Reset label and required when dialog opens
  useEffect(() => {
    if (open) {
      setLabel("");
      setRequired(false);
    }
  }, [open]);

  const handleConfirm = () => {
    if (label.trim()) {
      onConfirm(label.trim(), required);
      onClose();
    }
  };

  const typeLabel =
    FIELD_TYPES[fieldType as keyof typeof FIELD_TYPES] || fieldType;

  return (
    <Dialog open={open} onClose={onClose} sx={sx}>
      {" "}
      {/* FIXED: Forward sx to Dialog; removed maxWidth for consistency */}
      <DialogTitle>وارد کردن برچسب فیلد</DialogTitle>
      <DialogContent>
        <TextField
          autoFocus
          margin="dense"
          label={`برچسب برای "${typeLabel}" (مثال: نام، سن)`}
          fullWidth
          value={label}
          onChange={(e) => setLabel(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              handleConfirm();
            }
          }}
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={required}
              onChange={(e) => setRequired(e.target.checked)}
            />
          }
          label="الزامی"
        />
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>لغو</Button>
        <Button onClick={handleConfirm} disabled={!label.trim()}>
          افزودن فیلد
        </Button>
      </DialogActions>
    </Dialog>
  );
}


==================================================

FILE: src\components\formBuilder\dialogs\SelectOptionsDialog.tsx
----------------------------------------
// src/components/formBuilder/dialogs/SelectOptionsDialog.tsx (Updated to forward sx)
"use client";

import React from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Typography,
  List,
  ListItem,
  IconButton,
  Button,
} from "@mui/material";
import { Delete as DeleteIcon } from "@mui/icons-material";
import type { SelectOptionsDialogProps } from "../types";
import { useSelectOptionsDialog } from "../hooks/useSelectOptionsDialog";

export default function SelectOptionsDialog({
  open,
  onClose,
  onConfirm,
  initialOptions = [],
  sx, // FIXED: Accept sx prop
}: SelectOptionsDialogProps) {
  const {
    options,
    newOption,
    addOption,
    removeOption,
    handleConfirm,
    handleNewOptionChange,
    handleKeyDown,
  } = useSelectOptionsDialog({
    open,
    onClose,
    onConfirm,
    initialOptions,
  });

  return (
    <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth sx={sx}>
      {" "}
      {/* FIXED: Forward sx to Dialog */}
      <DialogTitle>مدیریت گزینه‌های انتخاب</DialogTitle>
      <DialogContent>
        <Typography variant="body1" sx={{ mb: 2 }}>
          گزینه‌ها را یکی یکی وارد کنید (مثال: &quot;گزینه ۱&quot;، &quot;گزینه
          ۲&quot;).
        </Typography>
        <TextField
          label="گزینه جدید"
          value={newOption}
          onChange={(e) => handleNewOptionChange(e.target.value)}
          onKeyDown={handleKeyDown}
          fullWidth
          sx={{ mb: 2 }}
        />
        <Button
          variant="outlined"
          onClick={addOption}
          disabled={!newOption.trim()}
          size="small"
          sx={{ mb: 2 }}
        >
          افزودن گزینه
        </Button>
        <List sx={{ maxHeight: 200, overflow: "auto" }}>
          {options.map((option, index) => (
            <ListItem
              key={index}
              secondaryAction={
                <IconButton
                  edge="end"
                  onClick={() => removeOption(index)}
                  size="small"
                >
                  <DeleteIcon />
                </IconButton>
              }
            >
              <Typography variant="body2">{option}</Typography>
            </ListItem>
          ))}
        </List>
        {options.length === 0 && (
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            هنوز گزینه‌ای اضافه نشده است.
          </Typography>
        )}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>لغو</Button>
        <Button onClick={handleConfirm} disabled={options.length === 0}>
          تأیید
        </Button>
      </DialogActions>
    </Dialog>
  );
}


==================================================

FILE: src\components\formBuilder\FormTypeBuilder.tsx
----------------------------------------
"use client";

import React, { useState, useCallback } from "react";
import { Box } from "@mui/material";
import type { FormTypeBuilderProps, FIELD_TYPES } from "./types";
import { useFormSchema } from "./hooks/useFormSchema";
import { useFieldAddition } from "./hooks/useFieldAddition";
import { useSnackbar } from "./hooks/useSnackbar";
import FieldTypeSelector from "./components/FieldTypeSelector";
import SchemaDisplay from "./components/SchemaDisplay";
import BuilderActions from "./components/BuilderActions";
import FieldLabelDialog from "./dialogs/FieldLabelDialog";
import SelectOptionsDialog from "./dialogs/SelectOptionsDialog";
import EntityRefDialog from "./dialogs/EntityRefDialog";
import DisplayFieldDialog from "./dialogs/DisplayFieldDialog";
import { validateFormName } from "./utils/validateFormName";
// FIXED: Remove unused CustomAccordion import

export default function FormTypeBuilder({
  initialSchema = {
    name: "",
    hasItems: false,
    headerFields: [],
    itemFields: [],
  },
  isEditing = false,
  onSave,
  onDelete,
  onCancel,
}: FormTypeBuilderProps) {
  const {
    formName,
    setFormName,
    hasItems,
    setHasItems,
    headerFields,
    itemFields,
    addField,
    deleteField,
    getSchema,
  } = useFormSchema({ initialSchema });

  const [selectedType, setSelectedType] =
    useState<keyof typeof FIELD_TYPES>("text");

  const {
    handleTypeChange,
    labelDialogOpen,
    setLabelDialogOpen,
    optionsDialogOpen,
    setOptionsDialogOpen,
    entityDialogOpen,
    setEntityDialogOpen,
    displayDialogOpen,
    setDisplayDialogOpen,
    handleAddField,
    handleLabelConfirm,
    handleOptionsConfirm,
    handleEntitySelect,
    handleDisplayConfirm,
    pendingTargetId,
  } = useFieldAddition({ selectedType, setSelectedType, addField });

  const { show } = useSnackbar();

  const handleSave = useCallback(async () => {
    const schema = getSchema();
    if (!validateFormName(schema.name)) {
      show("نام فرم الزامی است!", "error");
      return;
    }
    await onSave(schema);
  }, [getSchema, onSave, show]);

  const dialogSx = {
    "& .MuiDialog-paper": {
      borderRadius: 8,
      background: "rgba(0, 0, 0, 0.6)",
      backdropFilter: "blur(10px)",
      border: "1px solid rgba(255, 255, 255, 0.1)",
      boxShadow: "0 8px 32px rgba(0, 0, 0, 0.3)",
      width: "80vw",
      minHeight: "80vh",
      maxWidth: "none",
      p: 3,
    },
    "& .MuiDialogContent-root": {
      p: 3,
    },
  };

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        p: 0,
        width: "100%",
        mx: "auto",
        alignItems: "stretch",
      }}
    >
      <Box sx={{ display: "flex", flexDirection: "column", width: "100%" }}>
        <FieldTypeSelector
          selectedType={String(selectedType)}
          onTypeChange={(type: string) =>
            handleTypeChange(type as keyof typeof FIELD_TYPES)
          }
          onAddToHeader={() => handleAddField("header")}
          onAddToItems={() => handleAddField("items")}
          hasItems={hasItems}
        />
        <SchemaDisplay
          formName={formName}
          onFormNameChange={setFormName}
          hasItems={hasItems}
          onHasItemsChange={setHasItems}
          headerFields={headerFields}
          itemFields={itemFields}
          onDeleteField={deleteField}
        />
      </Box>

      <Box
        sx={{
          mt: 0.5,
          display: "flex",
          justifyContent: "center",
          width: "100%",
        }}
      >
        <BuilderActions
          formName={formName}
          hasItems={hasItems}
          headerFields={headerFields}
          itemFields={itemFields}
          isEditing={isEditing}
          onSave={handleSave}
          onDelete={onDelete}
          onCancel={onCancel}
        />
      </Box>

      {/* Dialogs with adjusted glassy styles */}
      <FieldLabelDialog
        open={labelDialogOpen}
        onClose={() => setLabelDialogOpen(false)}
        onConfirm={handleLabelConfirm}
        fieldType={String(selectedType)}
        sx={dialogSx}
      />

      <SelectOptionsDialog
        open={optionsDialogOpen}
        onClose={() => setOptionsDialogOpen(false)}
        onConfirm={handleOptionsConfirm}
        sx={dialogSx}
      />

      <EntityRefDialog
        open={entityDialogOpen}
        onClose={() => setEntityDialogOpen(false)}
        onSelect={handleEntitySelect}
        sx={dialogSx}
      />

      <DisplayFieldDialog
        open={displayDialogOpen}
        onClose={() => setDisplayDialogOpen(false)}
        onConfirm={handleDisplayConfirm}
        targetFormType={pendingTargetId}
        sx={dialogSx}
      />
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\FormTypeManager.tsx
----------------------------------------
import { useState, useEffect, useCallback, useMemo } from "react";
import { Box } from "@mui/material";
import FormTypeBuilder from "./FormTypeBuilder";
import ManagerTypeSelector from "./components/ManagerTypeSelector";
import NotificationSnackbar from "./components/NotificationSnackbar";
import { getDefaultSchema } from "./utils/getDefaultSchema";
import { getFormTypes } from "@/lib/appwrite";
import type {
  FormTypeManagerProps,
  FormSchema,
  FormType,
  RawFormType,
  Field,
} from "./types";
import { useFormTypeActions } from "./hooks/useFormTypeActions";

const parseFormType = (raw: RawFormType): FormType | null => {
  if (!raw.$id || !raw.name) return null;
  const defaultSchema = getDefaultSchema();
  if (!raw.schema || typeof raw.schema !== "object") {
    return { $id: raw.$id, name: raw.name, schema: defaultSchema };
  }
  const s = raw.schema as Record<string, unknown>;
  const isValidField = (f: unknown): f is Field => {
    return (
      !!f &&
      typeof f === "object" &&
      typeof (f as Record<string, unknown>).id === "string"
    );
  };
  const headerFields = Array.isArray(s.headerFields)
    ? (s.headerFields as unknown[]).filter(isValidField)
    : [];
  const itemFields = Array.isArray(s.itemFields)
    ? (s.itemFields as unknown[]).filter(isValidField)
    : [];
  const parsedSchema: FormSchema = {
    name: typeof s.name === "string" ? s.name : defaultSchema.name,
    hasItems:
      typeof s.hasItems === "boolean" ? s.hasItems : defaultSchema.hasItems,
    headerFields: headerFields as Field[],
    itemFields: itemFields as Field[],
  };
  return { $id: raw.$id, name: raw.name, schema: parsedSchema };
};

export default function FormTypeManager({
  onNewSave,
  onCancel,
}: FormTypeManagerProps) {
  const [selectedType, setSelectedType] = useState<string>("new");
  const [rawFormTypes, setRawFormTypes] = useState<RawFormType[]>([]);

  const currentSchema = useMemo(() => {
    if (selectedType === "new") return getDefaultSchema();
    const type = rawFormTypes
      .map(parseFormType)
      .filter((t): t is FormType => t !== null)
      .find((t) => t.$id === selectedType);
    return type?.schema || getDefaultSchema();
  }, [selectedType, rawFormTypes]);

  const formTypes = useMemo(
    () =>
      rawFormTypes.map(parseFormType).filter((t): t is FormType => t !== null),
    [rawFormTypes]
  );

  useEffect(() => {
    getFormTypes()
      // Explicitly type the response data
      .then((data: { $id: string; name: string; schema: object }[]) => {
        // Cast to RawFormType[] to satisfy state type
        setRawFormTypes(data as unknown as RawFormType[]);
      })
      .catch((err: unknown) =>
        console.error("Failed to load form types:", err)
      );
  }, []);

  const { handleSave, handleDelete } = useFormTypeActions({
    selectedType,
    setCurrentSchema: () => {},
    setSelectedType,
    onNewSave,
  });

  const handleTypeChange = useCallback((value: string) => {
    setSelectedType(value);
  }, []);

  const handleBuilderSave = useCallback(
    async (schema: FormSchema) => {
      await handleSave(schema);
      if (selectedType === "new") {
        onCancel();
      } else {
        setSelectedType("new");
      }
    },
    [handleSave, selectedType, onCancel]
  );

  const handleBuilderDelete = useCallback(async () => {
    await handleDelete();
    onCancel();
  }, [handleDelete, onCancel]);

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        p: 0.5,
        width: "100%",
        mx: "auto",
        alignItems: "stretch",
      }}
    >
      <ManagerTypeSelector
        selectedType={selectedType}
        onTypeChange={handleTypeChange}
        formTypes={formTypes}
      />
      <FormTypeBuilder
        initialSchema={currentSchema}
        isEditing={selectedType !== "new"}
        onSave={handleBuilderSave}
        onDelete={handleBuilderDelete}
        onCancel={onCancel}
      />
      <NotificationSnackbar />
    </Box>
  );
}


==================================================

FILE: src\components\formBuilder\hooks\useFieldAddition.ts
----------------------------------------
import { useState, useCallback } from "react";
import type { Field, FIELD_TYPES, UseFieldAdditionProps } from "../types";

export const useFieldAddition = ({
  selectedType,
  setSelectedType,
  addField,
}: UseFieldAdditionProps) => {
  const [labelDialogOpen, setLabelDialogOpen] = useState(false);
  const [optionsDialogOpen, setOptionsDialogOpen] = useState(false);
  const [entityDialogOpen, setEntityDialogOpen] = useState(false);
  const [displayDialogOpen, setDisplayDialogOpen] = useState(false);

  const [pendingZone, setPendingZone] = useState<"header" | "items" | null>(
    null
  );
  const [pendingType, setPendingType] = useState<
    keyof typeof FIELD_TYPES | null
  >(null);
  const [pendingLabel, setPendingLabel] = useState("");
  const [pendingRequired, setPendingRequired] = useState(false);
  const [pendingTargetId, setPendingTargetId] = useState<string>(""); // Target form $id

  const handleTypeChange = useCallback(
    (value: keyof typeof FIELD_TYPES) => setSelectedType(value),
    [setSelectedType]
  );

  const handleAddField = useCallback(
    (zone: "header" | "items") => {
      setPendingZone(zone);
      setPendingType(selectedType);
      setPendingRequired(false);
      setLabelDialogOpen(true);
    },
    [selectedType]
  );

  const handleLabelConfirm = useCallback(
    (label: string, required: boolean) => {
      if (!pendingZone || !pendingType) return;
      setPendingLabel(label);
      setPendingRequired(required);

      if (pendingType === "reference") {
        setEntityDialogOpen(true);
        return;
      }
      if (["select", "multiselect", "radio"].includes(pendingType)) {
        setOptionsDialogOpen(true);
        return;
      }

      addField(
        pendingZone,
        pendingType as Field["type"],
        label,
        undefined,
        undefined,
        required
      );
      setPendingZone(null);
      setPendingType(null);
      setLabelDialogOpen(false);
    },
    [pendingZone, pendingType, addField]
  );

  const handleOptionsConfirm = useCallback(
    (options: string[]) => {
      if (!pendingLabel || !pendingZone || !pendingType) return;
      addField(
        pendingZone,
        pendingType as Field["type"],
        pendingLabel,
        options,
        undefined,
        pendingRequired
      );
      setOptionsDialogOpen(false);
      setPendingLabel("");
      setPendingZone(null);
      setPendingType(null);
      setPendingRequired(false);
    },
    [pendingLabel, pendingZone, pendingType, pendingRequired, addField]
  );

  const handleEntitySelect = useCallback(
    (targetId: string) => {
      if (!pendingLabel || !pendingZone || !pendingType) return;
      setPendingTargetId(targetId);
      setDisplayDialogOpen(true);
    },
    [pendingLabel, pendingZone, pendingType]
  );

  const handleDisplayConfirm = useCallback(
    (displayField: string) => {
      if (!pendingLabel || !pendingZone || !pendingType || !pendingTargetId)
        return;

      addField(
        pendingZone,
        "reference" as Field["type"],
        pendingLabel,
        undefined,
        pendingTargetId,
        pendingRequired,
        displayField
      );

      setDisplayDialogOpen(false);
      setPendingLabel("");
      setPendingZone(null);
      setPendingType(null);
      setPendingTargetId("");
      setPendingRequired(false);
    },
    [
      pendingLabel,
      pendingZone,
      pendingType,
      pendingTargetId,
      pendingRequired,
      addField,
    ]
  );

  return {
    selectedType,
    handleTypeChange,
    labelDialogOpen,
    setLabelDialogOpen,
    optionsDialogOpen,
    setOptionsDialogOpen,
    entityDialogOpen,
    setEntityDialogOpen,
    displayDialogOpen,
    setDisplayDialogOpen,
    handleAddField,
    handleLabelConfirm,
    handleOptionsConfirm,
    handleEntitySelect,
    handleDisplayConfirm,
    pendingTargetId, // FIXED: Expose it
  };
};


==================================================

FILE: src\components\formBuilder\hooks\useFormSchema.ts
----------------------------------------
// FILE: src/components/formBuilder/hooks/useFormSchema.ts
import { useState, useEffect, useCallback, useRef } from "react";
import type { Field, UseFormSchemaProps } from "../types";
import { generateFieldId, buildSchema } from "../utils/utils";

export function useFormSchema({ initialSchema }: UseFormSchemaProps) {
  // Use refs to store previous values for comparison
  const prevSchemaRef = useRef(initialSchema);

  const [formName, setFormName] = useState(initialSchema.name);
  const [hasItems, setHasItems] = useState(initialSchema.hasItems);
  const [headerFields, setHeaderFields] = useState<Field[]>(
    initialSchema.headerFields
  );
  const [itemFields, setItemFields] = useState<Field[]>(
    initialSchema.itemFields
  );

  // FIXED: Only update if initialSchema actually changed (deep comparison)
  useEffect(() => {
    // Skip if same reference or shallow equal
    if (prevSchemaRef.current === initialSchema) return;

    // Shallow check for changes
    const hasChanged =
      prevSchemaRef.current.name !== initialSchema.name ||
      prevSchemaRef.current.hasItems !== initialSchema.hasItems ||
      prevSchemaRef.current.headerFields !== initialSchema.headerFields ||
      prevSchemaRef.current.itemFields !== initialSchema.itemFields;

    if (hasChanged) {
      setFormName(initialSchema.name);
      setHasItems(initialSchema.hasItems);
      setHeaderFields(initialSchema.headerFields);
      setItemFields(initialSchema.itemFields);
    }

    // Update ref
    prevSchemaRef.current = initialSchema;
  }, [initialSchema]); // Only re-run when initialSchema reference changes

  const addField = useCallback(
    (
      zone: "header" | "items",
      type: Field["type"],
      label: string,
      options?: string[],
      targetFormType?: string,
      required: boolean = false,
      displayField?: string
    ) => {
      const newField: Field = {
        id: generateFieldId(),
        type,
        label,
        required,
        options,
        ...(targetFormType && { targetFormType }),
        ...(displayField && { displayField }),
      };

      if (zone === "header") {
        setHeaderFields((prev) => [...prev, newField]);
      } else if (hasItems) {
        setItemFields((prev) => [...prev, newField]);
      }
    },
    [hasItems]
  );

  const deleteField = useCallback((id: string, isHeader: boolean) => {
    if (isHeader) {
      setHeaderFields((prev) => prev.filter((f) => f.id !== id));
    } else {
      setItemFields((prev) => prev.filter((f) => f.id !== id));
    }
  }, []);

  const getSchema = useCallback(() => {
    return buildSchema(formName, hasItems, headerFields, itemFields);
  }, [formName, hasItems, headerFields, itemFields]);

  return {
    formName,
    setFormName,
    hasItems,
    setHasItems,
    headerFields,
    itemFields,
    addField,
    deleteField,
    getSchema,
  };
}


==================================================

FILE: src\components\formBuilder\hooks\useFormTypeActions.ts
----------------------------------------
import { useCallback } from "react";
import type { FormSchema } from "../types";
import { useSnackbar } from "./useSnackbar";
import { validateFormName } from "../utils/validateFormName";
import { updateFormType, deleteFormType } from "@/lib/appwrite"; // Changed Import

export interface UseFormTypeActionsProps {
  selectedType: string;
  setCurrentSchema: React.Dispatch<React.SetStateAction<FormSchema>>;
  setSelectedType: React.Dispatch<React.SetStateAction<string>>;
  onNewSave: (schema: FormSchema) => Promise<void>;
}

export const useFormTypeActions = ({
  selectedType,
  setCurrentSchema,
  setSelectedType,
  onNewSave,
}: UseFormTypeActionsProps) => {
  const { show } = useSnackbar();

  const handleSave = useCallback(
    async (schema: FormSchema) => {
      if (selectedType === "new") {
        await onNewSave(schema);
        show("نوع فرم با موفقیت ایجاد شد!");
        return;
      }

      if (!validateFormName(schema.name)) {
        show("نام فرم الزامی است!", "error");
        return;
      }

      // REPLACED: fetch(PUT) -> updateFormType()
      const result = await updateFormType(selectedType, schema.name, schema);

      if (result.success) {
        setCurrentSchema(schema);
        show("نوع فرم با موفقیت به‌روزرسانی شد!");
      } else {
        show("خطا در ذخیره نوع فرم", "error");
      }
    },
    [selectedType, setCurrentSchema, onNewSave, show]
  );

  const handleDelete = useCallback(async () => {
    if (selectedType === "new") return;

    if (
      window.confirm("آیا مطمئن هستید که می‌خواهید این نوع فرم را حذف کنید؟")
    ) {
      // REPLACED: fetch(DELETE) -> deleteFormType()
      const result = await deleteFormType(selectedType);

      if (result.success) {
        show("نوع فرم با موفقیت حذف شد!");
        setSelectedType("new");
      } else {
        show("خطا در حذف نوع فرم", "error");
      }
    }
  }, [selectedType, setSelectedType, show]);

  return { handleSave, handleDelete };
};


==================================================

FILE: src\components\formBuilder\hooks\useformtypeactiontest.tsx
----------------------------------------
// src/components/formbuilder/hooks/useFormTypeActions.ts
import { useCallback } from "react";
import type { FormSchema, UseFormTypeActionsProps } from "../types";
import { updateFormType, deleteFormType } from "@/lib/appwrite";
import { useSnackbar } from "./useSnackbar";
import { validateFormName } from "../utils/validateFormName";

export const useFormTypeActions = ({
  selectedType,
  setCurrentSchema,
  setSelectedType,
  onNewSave,
}: UseFormTypeActionsProps) => {
  const { show } = useSnackbar();

  const handleSave = useCallback(
    async (schema: FormSchema) => {
      if (selectedType === "new") {
        await onNewSave(schema);
        return;
      }

      if (!validateFormName(schema.name)) {
        show("نام فرم الزامی است!", "error");
        return;
      }

      const result = await updateFormType(selectedType, schema.name, schema);
      if (result.success) {
        setCurrentSchema(schema);
        show("نوع فرم با موفقیت به‌روزرسانی شد!");
      } else {
        show("خطا در ذخیره نوع فرم", "error");
      }
    },
    [selectedType, setCurrentSchema, onNewSave, show]
  );

  const handleDelete = useCallback(async () => {
    if (selectedType === "new") return;

    if (
      window.confirm("آیا مطمئن هستید که می‌خواهید این نوع فرم را حذف کنید؟")
    ) {
      const result = await deleteFormType(selectedType);
      if (result.success) {
        show("نوع فرم با موفقیت حذف شد!");
        setSelectedType("new");
      } else {
        show("خطا در حذف نوع فرم", "error");
      }
    }
  }, [selectedType, setSelectedType, show]);

  return { handleSave, handleDelete };
};


==================================================

FILE: src\components\formBuilder\hooks\useFormTypes.ts
----------------------------------------
import { useState, useEffect } from "react";
import { getFormTypes } from "@/lib/appwrite";
import { FormType, FormSchema, RawFormType } from "../types/index"; // Import FormSchema for casting

export function useFormTypes() {
  const [formTypes, setFormTypes] = useState<FormType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTypes = async () => {
      try {
        setLoading(true);
        const types: RawFormType[] = await getFormTypes();
        // Map to typed FormType
        const typedTypes: FormType[] = types.map((type) => ({
          $id: type.$id,
          name: type.name,
          schema: type.schema as FormSchema, // Safe cast now that we have the interface
        }));
        setFormTypes(typedTypes);
        setError(null);
      } catch (err) {
        setError("خطا در بارگذاری انواع فرم");
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchTypes();
  }, []);

  return {
    formTypes,
    loading,
    error,
    refetch: () => {
      /* optional refetch logic */
    },
  };
}


==================================================

FILE: src\components\formBuilder\hooks\useSelectOptionsDialog.ts
----------------------------------------
// src/components/formbuilder/hooks/useSelectOptionsDialog.ts
import { useState, useEffect, useRef, useCallback } from "react";
import type { SelectOptionsDialogProps } from "../types";

export const useSelectOptionsDialog = ({
  open,
  onClose,
  onConfirm,
  initialOptions = [],
}: SelectOptionsDialogProps) => {
  const [options, setOptions] = useState<string[]>([]);
  const [newOption, setNewOption] = useState("");
  const prevOpenRef = useRef(false);

  // Reset only when dialog opens (from closed to open), avoiding loops from unstable initialOptions
  useEffect(() => {
    if (open && !prevOpenRef.current) {
      setOptions([...initialOptions]); // Shallow copy to avoid mutation issues
      setNewOption("");
    }
    prevOpenRef.current = open;
  }, [open, initialOptions]); // Safe: initialOptions only used on open transition

  const addOption = useCallback(() => {
    if (newOption.trim()) {
      setOptions((prev) => [...prev, newOption.trim()]);
      setNewOption("");
    }
  }, [newOption]);

  const removeOption = useCallback((index: number) => {
    setOptions((prev) => prev.filter((_, i) => i !== index));
  }, []);

  const handleConfirm = useCallback(() => {
    onConfirm(options);
    onClose();
  }, [options, onConfirm, onClose]);

  const handleNewOptionChange = useCallback((value: string) => {
    setNewOption(value);
  }, []);

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (e.key === "Enter") {
        e.preventDefault();
        addOption();
      }
    },
    [addOption]
  );

  return {
    options,
    newOption,
    addOption,
    removeOption,
    handleConfirm,
    handleNewOptionChange,
    handleKeyDown,
  };
};


==================================================

FILE: src\components\formBuilder\hooks\useSnackbar.ts
----------------------------------------
import { useState } from "react";
import { AlertColor } from "@mui/material";
import type { SnackbarState } from "../types/index";

export function useSnackbar(
  initialState: SnackbarState = {
    open: false,
    message: "",
    severity: "success",
  }
) {
  const [snackbar, setSnackbar] = useState<SnackbarState>(initialState);

  const show = (message: string, severity: AlertColor = "success") => {
    setSnackbar({ open: true, message, severity });
  };

  const close = () => {
    setSnackbar((prev) => ({ ...prev, open: false }));
  };

  return { snackbar, show, close };
}


==================================================

FILE: src\components\formBuilder\types\index.ts
----------------------------------------
// src/components/formBuilder/types/index.ts (Updated with sx props for dialogs)
import { AlertColor, SxProps, Theme } from "@mui/material";

export type FieldType = // Match main.js exactly

    | "text"
    | "textarea"
    | "number"
    | "integer"
    | "decimal"
    | "email"
    | "password"
    | "url"
    | "date"
    | "datetime"
    | "time"
    | "select"
    | "multiselect"
    | "checkbox"
    | "radio"
    | "file"
    | "image"
    | "hidden"
    | "reference"
    | "boolean";

export interface Field {
  id: string;
  type: FieldType;
  label: string;
  required?: boolean;
  options?: string[];
  targetFormType?: string; // For 'reference'
  displayField?: string; // For 'reference'
  multiple?: boolean; // For 'multiselect'
}

export interface FormSchema {
  name: string;
  hasItems: boolean;
  headerFields: Field[];
  itemFields: Field[];
}

// Full form type from DB (extends schema for storage)
export interface FormType {
  $id: string;
  name: string;
  schema: FormSchema;
}

// Persian labels for field types (used in selects and chips)
export const FIELD_TYPES: { [key in FieldType]: string } = {
  text: "فیلد متنی",
  textarea: "فیلد متنی چندخطی",
  number: "فیلد عددی",
  integer: "عدد صحیح",
  decimal: "عدد اعشاری",
  email: "ایمیل",
  password: "رمز عبور",
  url: "آدرس وب",
  date: "تاریخ",
  datetime: "تاریخ و زمان",
  time: "زمان",
  select: "لیست کشویی",
  multiselect: "چند انتخابی",
  checkbox: "چک‌باکس",
  radio: "دکمه رادیویی",
  file: "فایل",
  image: "تصویر",
  hidden: "مخفی",
  reference: "مرجع موجودیت",
  boolean: "بولی",
};

// Short Persian chips for field types
export const TYPE_TO_PERSIAN: { [key in FieldType]: string } = {
  text: "متنی",
  textarea: "متنی چندخطی",
  number: "عددی",
  integer: "عدد صحیح",
  decimal: "اعشاری",
  email: "ایمیل",
  password: "رمز",
  url: "وب",
  date: "تاریخ",
  datetime: "تاریخ/زمان",
  time: "زمان",
  select: "انتخابی",
  multiselect: "چندانتخابی",
  checkbox: "چک‌باکس",
  radio: "رادیویی",
  file: "فایل",
  image: "تصویر",
  hidden: "مخفی",
  reference: "مرجع",
  boolean: "بولی",
};

export interface FormTypeManagerProps {
  onNewSave: (schema: FormSchema) => Promise<void>;
  onCancel: () => void;
}

export interface FormTypeBuilderProps {
  initialSchema: FormSchema;
  isEditing?: boolean;
  onSave: (schema: FormSchema) => Promise<void>;
  onDelete?: () => void;
  onCancel?: () => void;
}

export interface SnackbarState {
  open: boolean;
  message: string;
  severity: AlertColor;
}

export interface SelectOptionsDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (options: string[]) => void;
  initialOptions?: string[];
  sx?: SxProps<Theme>; // FIXED: Added sx for glassy styling
}

export interface FieldLabelDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (label: string, required: boolean) => void;
  fieldType: string;
  sx?: SxProps<Theme>; // FIXED: Added sx for glassy styling
}

export interface EntityRefDialogProps {
  open: boolean;
  onClose: () => void;
  onSelect: (target: string) => void;
  sx?: SxProps<Theme>; // FIXED: Added sx for glassy styling
}

export interface DisplayFieldDialogProps {
  open: boolean;
  onClose: () => void;
  onConfirm: (displayField: string) => void;
  targetFormType?: string;
  sx?: SxProps<Theme>; // FIXED: Added sx for glassy styling
}

export interface SchemaDisplayProps {
  formName: string;
  onFormNameChange: (name: string) => void;
  hasItems: boolean;
  onHasItemsChange: (hasItems: boolean) => void;
  headerFields: Field[];
  itemFields: Field[];
  onDeleteField: (id: string, isHeader: boolean) => void;
}

export interface ManagerTypeSelectorProps {
  selectedType: string;
  onTypeChange: (type: string) => void; // Explicitly string (no union)
}

export interface FieldTypeSelectorProps {
  selectedType: string; // Keeps as string (union of literals assignable)
  onTypeChange: (type: string) => void;
  onAddToHeader: () => void;
  onAddToItems: () => void;
  hasItems: boolean;
}

export interface BuilderActionsProps {
  formName: string;
  hasItems: boolean;
  headerFields: Field[];
  itemFields: Field[];
  isEditing: boolean;
  onSave: (schema: FormSchema) => Promise<void>;
  onDelete?: () => void;
  onCancel?: () => void;
}

export interface RawFormType {
  $id: string;
  name: string;
  schema: unknown; // Start loose, cast later
}

export interface UseFormTypeActionsProps {
  selectedType: string;
  setCurrentSchema: (schema: FormSchema) => void;
  setSelectedType: (type: string) => void;
  onNewSave: (schema: FormSchema) => Promise<void>;
}

export interface UseFormSchemaProps {
  initialSchema: FormSchema;
}

export interface UseFieldAdditionProps {
  selectedType: keyof typeof FIELD_TYPES;
  setSelectedType: (type: keyof typeof FIELD_TYPES) => void;
  addField: (
    zone: "header" | "items",
    type: Field["type"],
    label: string,
    options?: string[],
    targetId?: string,
    required?: boolean,
    displayField?: string // NEW
  ) => void;
}

export interface FieldsListProps {
  fields: Field[];
  isHeader: boolean;
  onDeleteField: (id: string, isHeader: boolean) => void;
  formTypes: FormType[];
}

export interface FieldChipsProps {
  field: Field;
  getReferenceName: (targetId: string) => string;
}


==================================================

FILE: src\components\formBuilder\utils\getDefaultSchema.ts
----------------------------------------
// src/components/formbuilder/utils/getDefaultSchema.ts
import type { FormSchema } from "../types";

export function getDefaultSchema(): FormSchema {
  return {
    name: "",
    hasItems: false,
    headerFields: [],
    itemFields: [],
  };
}


==================================================

FILE: src\components\formBuilder\utils\getFieldDisplayLabel.ts
----------------------------------------
// src/components/formbuilder/utils/getFieldDisplayLabel.ts
import type { Field } from "../types";

export function getFieldDisplayLabel(field: Field): string {
  return field.label;
}


==================================================

FILE: src\components\formBuilder\utils\getReferenceName.ts
----------------------------------------
// src/components/formbuilder/utils/getReferenceName.ts
import type { FormType } from "../types";

export function getReferenceName(
  formTypes: FormType[],
  targetId: string
): string {
  const target = formTypes.find((type) => type.$id === targetId);
  return target ? target.name : "نامشخص";
}


==================================================

FILE: src\components\formBuilder\utils\getSchemaById.ts
----------------------------------------
// src/components/formbuilder/utils/getSchemaById.ts
import type { FormType, FormSchema } from "../types";

export function getSchemaById(
  formTypes: FormType[],
  id: string
): FormSchema | null {
  const type = formTypes.find((t) => t.$id === id);
  return type ? type.schema : null;
}


==================================================

FILE: src\components\formBuilder\utils\utils.ts
----------------------------------------
// Utility functions for form builder operations.
// These are pure or side-effect-free helpers to keep components lean.

import { Field, FormSchema, FIELD_TYPES } from "../types";

/**
 * Generates a unique ID for a new field.
 * Uses timestamp + random string for collision resistance.
 */
export function generateFieldId(): string {
  return `field-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Generic function to delete a field from an array by ID and update state.
 * @param fields - Current array of fields
 * @param id - ID of field to remove
 * @param setter - State setter to update the array (e.g., setHeaderFields)
 */
export function deleteField(
  fields: Field[],
  id: string,
  setter: React.Dispatch<React.SetStateAction<Field[]>>
): void {
  setter((prev) => prev.filter((f) => f.id !== id));
}

/**
 * Builds a display label for a field, with fallback if label is empty.
 * @param field - The field object
 * @returns Formatted label string
 */
export function getFieldDisplayLabel(field: Field): string {
  return (
    field.label ||
    `بدون عنوان ${FIELD_TYPES[field.type as keyof typeof FIELD_TYPES]}`
  );
}

/**
 * Assembles the full FormSchema from component state.
 * Ensures itemFields is empty if !hasItems.
 * @param formName - Form name string
 * @param hasItems - Boolean for items support
 * @param headerFields - Header fields array
 * @param itemFields - Item fields array
 * @returns Complete FormSchema
 */
export function buildSchema(
  formName: string,
  hasItems: boolean,
  headerFields: Field[],
  itemFields: Field[]
): FormSchema {
  return {
    name: formName,
    hasItems,
    headerFields,
    itemFields: hasItems ? itemFields : [],
  };
}


==================================================

FILE: src\components\formBuilder\utils\validateFormName.ts
----------------------------------------
// src/components/formbuilder/utils/validateFormName.ts
export function validateFormName(name: string): boolean {
  return !!name.trim();
}


==================================================

FILE: src\components\Layout.tsx
----------------------------------------
import React from "react";
import { Box, AppBar, Toolbar, Typography, IconButton } from "@mui/material";
import { Link, Outlet, useLocation } from "react-router-dom";
import YouTubeIcon from "@mui/icons-material/YouTube";
import GitHubIcon from "@mui/icons-material/GitHub";
import HomeIcon from "@mui/icons-material/Home";
import InfoIcon from "@mui/icons-material/Info";

export default function Layout() {
  const location = useLocation();

  return (
    <Box
      sx={{
        display: "flex",
        flexDirection: "column",
        minHeight: "100vh",
        bgcolor: "#000000", // Force background
      }}
    >
      {/* --- MENU BAR --- */}
      <AppBar
        position="static"
        elevation={0}
        sx={{
          bgcolor: "transparent",
          borderBottom: "1px solid rgba(255,255,255,0.1)",
        }}
      >
        <Toolbar sx={{ justifyContent: "space-between", direction: "rtl" }}>
          <Box sx={{ display: "flex", gap: 2 }}>
            <Link to="/">
              <IconButton
                sx={{ color: location.pathname === "/" ? "#FFC400" : "white" }}
              >
                <HomeIcon />
              </IconButton>
            </Link>
            <Link to="/about">
              <IconButton
                sx={{
                  color: location.pathname === "/about" ? "#FFC400" : "white",
                }}
              >
                <InfoIcon />
              </IconButton>
            </Link>
          </Box>

          <Typography
            variant="h6"
            sx={{
              fontWeight: "bold",
              color: "white",
              fontFamily: "FarNazanin",
            }}
          >
            مادر فرم‌ها
          </Typography>
        </Toolbar>
      </AppBar>

      {/* --- PAGE CONTENT --- */}
      <Box sx={{ flexGrow: 1 }}>
        <Outlet />
      </Box>

      {/* --- FOOTER --- */}
      <Box
        component="footer"
        sx={{
          py: 3,
          px: 2,
          mt: "auto",
          borderTop: "1px solid rgba(255,255,255,0.1)",
          bgcolor: "#000000",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: 3,
        }}
      >
        <a
          href="https://www.youtube.com/@pishnahadebehtar"
          target="_blank"
          rel="noopener noreferrer"
          style={{ color: "white" }}
        >
          <YouTubeIcon sx={{ fontSize: 30, "&:hover": { color: "#FF0000" } }} />
        </a>
        <a
          href="https://github.com/pishnahadebehtar/mother-of-all-forms"
          target="_blank"
          rel="noopener noreferrer"
          style={{ color: "white" }}
        >
          <GitHubIcon
            sx={{ fontSize: 28, "&:hover": { color: "#ffffffaa" } }}
          />
        </a>
      </Box>
    </Box>
  );
}


==================================================

FILE: src\components\listViewer\components\ColumnGenerator.tsx
----------------------------------------
import { useMemo } from "react";
import { GridColDef } from "@mui/x-data-grid";
import { Field, Schema, TableData, ListType } from "../types";

export function useColumnGenerator(listType: ListType, data: TableData[]) {
  return useMemo(() => {
    if (listType === "formTypes") {
      return [
        { field: "$id", headerName: "شناسه", width: 90 },
        { field: "name", headerName: "نام", width: 150 },
      ] as GridColDef[];
    }

    if (data.length > 0 && data[0].schema) {
      const schema = data[0].schema as Schema;
      const columns: GridColDef[] = [
        { field: "$id", headerName: "شناسه", width: 90 },
      ];

      schema.headerFields.forEach((field: Field) => {
        // CHANGED: Use raw field.label as key (with spaces); no replace
        const key = field.label;
        columns.push({
          field: `h_${key}`, // Prefix to avoid conflicts, but use raw key in valueGetter
          headerName: field.label,
          width: 150,
          valueGetter: (value, row: TableData) => {
            const rowData = row.data;
            if (!rowData?.header) return "";

            // CHANGED: Access with raw key (spaces)
            const val = rowData.header[key];
            if (val == null) return "";

            // Enhanced: Format based on type
            const fieldType = field.type as string;
            switch (fieldType) {
              case "datetime":
              case "date":
                return val instanceof Date
                  ? val.toLocaleDateString("fa-IR")
                  : String(val);
              case "time":
                return val instanceof Date
                  ? val.toLocaleTimeString("fa-IR")
                  : String(val);
              case "boolean":
              case "checkbox":
                return val ? "بله" : "خیر";
              case "file":
              case "image":
                return typeof val === "string"
                  ? val.split("/").pop() || val
                  : String(val); // Filename
              default:
                return typeof val === "boolean"
                  ? val
                    ? "بله"
                    : "خیر"
                  : String(val);
            }
          },
        });
      });

      if (schema.hasItems) {
        columns.push({
          field: "items_count",
          headerName: "تعداد اقلام",
          width: 120,
          valueGetter: (value, row: TableData) => {
            const rowData = row.data;
            return rowData?.items?.length || 0;
          },
        });
      }

      return columns;
    }

    return [
      { field: "$id", headerName: "شناسه", width: 90 },
      {
        field: "data",
        headerName: "داده",
        width: 300,
        valueGetter: (value, row: TableData) => {
          return row.data ? JSON.stringify(row.data, null, 2) : "بدون داده";
        },
      },
    ] as GridColDef[];
  }, [listType, data]);
}


==================================================

FILE: src\components\listViewer\components\EditAccordion.tsx
----------------------------------------
"use client";

import React from "react";
import { Box, Button } from "@mui/material";
import type { EditFormProps, BaseRowData, Schema, FormSchema } from "../types";
import FormTypeBuilder from "@/components/formBuilder/FormTypeBuilder";
import DynamicForm from "@/components/dynamicForm/DynamicForm";
import CustomAccordion from "@/components/CustomAccordion";

export function EditAccordion<T extends BaseRowData>({
  row,
  type,
  onSave,
  onCancel,
  onDelete,
}: EditFormProps<T>) {
  const defaultInitialData = { header: {}, items: [] };
  const safeInitialData = row.data
    ? (row.data as typeof defaultInitialData)
    : defaultInitialData;

  const handleDeleteClick = async () => {
    if (confirm(type === "formTypes" ? "حذف نوع فرم؟" : "حذف رکورد؟")) {
      await onDelete(row.$id);
    }
  };

  // FIXED: For records, add dummy name to make Schema -> FormSchema
  const schemaForForm: FormSchema =
    type === "formTypes"
      ? (row.schema as FormSchema)
      : {
          name: "رکورد موقت",
          ...(row.schema as Schema),
        };

  return (
    <CustomAccordion
      title={`ویرایش ${type === "formTypes" ? "نوع فرم" : "رکورد"}`}
      defaultExpanded={true}
      sx={{ mt: 2 }}
    >
      <Box sx={{ p: 2, maxHeight: 600, overflow: "auto" }}>
        {type === "formTypes" ? (
          <FormTypeBuilder
            initialSchema={schemaForForm}
            onSave={async (updatedSchema) => {
              await onSave(row.$id, updatedSchema);
              onCancel();
            }}
            onCancel={onCancel}
          />
        ) : (
          <DynamicForm
            schema={schemaForForm} // FIXED: Now FormSchema with name
            initialData={safeInitialData}
            onSubmit={async (data) => {
              await onSave(row.$id, data);
              onCancel();
            }}
            onCancel={onCancel}
          />
        )}
        <Button onClick={handleDeleteClick} color="error" sx={{ mt: 2 }}>
          حذف
        </Button>
      </Box>
    </CustomAccordion>
  );
}


==================================================

FILE: src\components\listViewer\components\ListSelector.tsx
----------------------------------------
// features/listViewer/components/ListSelector.tsx
import React from "react";
import { Box, Select, MenuItem, FormControl, InputLabel } from "@mui/material";
import { ListType, ListSelectorProps } from "../types";

export function ListSelector({
  listType,
  onListTypeChange,
  selectedFormType,
  onFormTypeChange,
  formTypes,
}: ListSelectorProps) {
  return (
    <Box sx={{ mb: 2 }}>
      <FormControl fullWidth>
        <InputLabel>نوع لیست</InputLabel>
        <Select
          value={listType}
          label="نوع لیست"
          onChange={(e) => onListTypeChange(e.target.value as ListType)}
        >
          <MenuItem value="formTypes">انواع فرم</MenuItem>
          <MenuItem value="records">رکوردها</MenuItem>
        </Select>
      </FormControl>

      {listType === "records" && (
        <FormControl fullWidth sx={{ mt: 2 }}>
          <InputLabel>نوع فرم</InputLabel>
          <Select
            value={selectedFormType}
            label="نوع فرم"
            onChange={(e) => onFormTypeChange(e.target.value as string)}
          >
            <MenuItem value="">یک نوع انتخاب کنید</MenuItem>
            {formTypes.map((type) => (
              <MenuItem key={type.$id} value={type.$id}>
                {type.name}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      )}
    </Box>
  );
}


==================================================

FILE: src\components\listViewer\components\ListTable.tsx
----------------------------------------
import  { useState } from "react";
import { DataGrid, GridColDef, GridRowParams } from "@mui/x-data-grid";
import { Box } from "@mui/material";
import type { ListTableProps, BaseRowData } from "../types";
import { EditAccordion } from "./EditAccordion";
import { useListActions } from "../hooks/useListActions";

// REMOVED: next/dynamic imports. Standard import works fine in Vite SPAs.

interface ExtendedListTableProps<T extends BaseRowData>
  extends ListTableProps<T> {
  onRefetch?: () => void;
  onSuccess?: (message: string) => void;
  onError?: (message: string) => void;
}

export default function ListTable<T extends BaseRowData>({
  data,
  columns,
  type,
  onRefetch,
  onSuccess,
  onError,
}: ExtendedListTableProps<T>) {
  const [expandedRow, setExpandedRow] = useState<string | null>(null);

  const { handleSaveEdit, handleDelete } = useListActions({
    type,
    onRefetch,
    onSuccess,
    onError,
  });

  const handleRowClick = (params: GridRowParams) => {
    setExpandedRow((prev) =>
      prev === params.id ? null : params.id.toString()
    );
  };

  const selectedRow = data.find((r) => r.$id === expandedRow);

  return (
    <Box sx={{ height: "auto", minHeight: 400, width: "100%" }}>
      <DataGrid
        rows={data}
        columns={columns as GridColDef[]}
        onRowClick={handleRowClick}
        getRowId={(row) => row.$id}
        disableRowSelectionOnClick
        slots={{ noRowsOverlay: () => <span>بدون داده</span> }}
        sx={{ mb: 2 }}
      />
      {expandedRow && selectedRow && (
        <EditAccordion
          row={selectedRow}
          type={type}
          onSave={handleSaveEdit}
          onCancel={() => setExpandedRow(null)}
          onDelete={handleDelete}
        />
      )}
    </Box>
  );
}


==================================================

FILE: src\components\listViewer\components\NotificationSnackbar.tsx
----------------------------------------
// src/components/listViewer/components/NotificationSnackbar.tsx
// Copied/adapted from form builder for consistency
"use client";

import React from "react";
import { Snackbar, Alert } from "@mui/material";
import { useSnackbar } from "../hooks/useSnackbar";

export default function NotificationSnackbar() {
  const { snackbar, close } = useSnackbar();

  return (
    <Snackbar
      open={snackbar.open}
      autoHideDuration={6000}
      onClose={close}
      anchorOrigin={{ vertical: "bottom", horizontal: "left" }}
    >
      <Alert
        onClose={close}
        severity={snackbar.severity}
        variant="filled"
        sx={{ width: "100%" }}
      >
        {snackbar.message}
      </Alert>
    </Snackbar>
  );
}


==================================================

FILE: src\components\listViewer\components\TableLoading.tsx
----------------------------------------
// src/components/listViewer/components/TableLoading.tsx
import React from "react";
import { Box, CircularProgress } from "@mui/material";

export default function TableLoading() {
  return (
    <Box
      sx={{
        height: 400,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      <CircularProgress size={60} />
    </Box>
  );
}


==================================================

FILE: src\components\listViewer\hooks\useFormTypes.ts
----------------------------------------
import { useState, useEffect, useCallback } from "react";
import { FormType } from "../types";
import { getFormTypes } from "@/lib/appwrite";

export function useFormTypes() {
  const [formTypes, setFormTypes] = useState<FormType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchFormTypes = useCallback(async () => {
    try {
      setLoading(true);
      // REPLACED: fetch -> getFormTypes
      const types = await getFormTypes();
      setFormTypes(types as FormType[]);
      setError(null);
    } catch (err) {
      setError("Failed to fetch form types");
      console.error("Error fetching form types:", err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchFormTypes();
  }, [fetchFormTypes]);

  return { formTypes, loading, error, refetch: fetchFormTypes };
}


==================================================

FILE: src\components\listViewer\hooks\useformtypetest.ts
----------------------------------------
// features/listViewer/hooks/useFormTypes.ts
import { useState, useEffect } from "react";
import { FormType } from "../types";
import { getFormTypes } from "@/lib/appwrite";

export function useFormTypes() {
  const [formTypes, setFormTypes] = useState<FormType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchFormTypes = async () => {
    try {
      setLoading(true);
      const types = await getFormTypes();
      setFormTypes(types as FormType[]);
      setError(null);
    } catch (err) {
      setError("Failed to fetch form types");
      console.error("Error fetching form types:", err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchFormTypes();
  }, []);

  const refetch = fetchFormTypes;

  return { formTypes, loading, error, refetch };
}


==================================================

FILE: src\components\listViewer\hooks\useListActions.ts
----------------------------------------
import { useCallback } from "react";
import { updateEntity } from "../utils/updateEntity";
import { deleteEntity } from "../utils/deleteEntity";
import { getEntityDeleteMessage } from "../utils/getEntityDeleteMessage";

interface UseListActionsProps {
  type: string;
  onRefetch?: () => void;
  onSuccess?: (message: string) => void;
  onError?: (message: string) => void;
}

export const useListActions = ({
  type,
  onRefetch,
  onSuccess,
  onError,
}: UseListActionsProps) => {
  const handleSaveEdit = useCallback(
    async (id: string, updatedData: object): Promise<void> => {
      // Uses our updated utils instead of fetch
      const result = await updateEntity(id, updatedData, type);
      if (result?.success) {
        onRefetch?.();
        onSuccess?.("به‌روزرسانی با موفقیت انجام شد!");
      } else {
        onError?.("خطا در به‌روزرسانی رکورد");
      }
    },
    [type, onRefetch, onSuccess, onError]
  );

  const handleDelete = useCallback(
    async (id: string): Promise<void> => {
      const message = getEntityDeleteMessage(type);
      if (confirm(message)) {
        // Uses our updated utils
        const result = await deleteEntity(id, type);
        if (result.success) {
          onRefetch?.();
          onSuccess?.("حذف با موفقیت انجام شد!");
        } else {
          onError?.("خطا در حذف رکورد");
        }
      }
    },
    [type, onRefetch, onSuccess, onError]
  );

  return { handleSaveEdit, handleDelete };
};


==================================================

FILE: src\components\listViewer\hooks\uselistactiontest.ts
----------------------------------------
import { useCallback } from "react";
import { updateEntity } from "../utils/updateEntity";
import { deleteEntity } from "../utils/deleteEntity";
import { getEntityDeleteMessage } from "../utils/getEntityDeleteMessage";

interface UseListActionsProps {
  type: string;
  onRefetch?: () => void;
  onSuccess?: (message: string) => void; // Success callback
  onError?: (message: string) => void; // NEW: Error callback
}

export const useListActions = ({
  type,
  onRefetch,
  onSuccess,
  onError, // NEW
}: UseListActionsProps) => {
  const handleSaveEdit = useCallback(
    async (id: string, updatedData: object): Promise<void> => {
      const result = await updateEntity(id, updatedData, type);
      if (result?.success) {
        onRefetch?.();
        onSuccess?.("به‌روزرسانی با موفقیت انجام شد!");
      } else {
        onError?.("خطا در به‌روزرسانی رکورد"); // NEW: Error message
      }
    },
    [type, onRefetch, onSuccess, onError]
  );

  const handleDelete = useCallback(
    async (id: string): Promise<void> => {
      const message = getEntityDeleteMessage(type);
      if (confirm(message)) {
        const result = await deleteEntity(id, type);
        if (result.success) {
          onRefetch?.();
          onSuccess?.("حذف با موفقیت انجام شد!");
        } else {
          onError?.("خطا در حذف رکورد"); // NEW: Error message
        }
      }
    },
    [type, onRefetch, onSuccess, onError]
  );

  return { handleSaveEdit, handleDelete };
};


==================================================

FILE: src\components\listViewer\hooks\useListData.ts
----------------------------------------
// src/components/listViewer/hooks/useListData.ts
import { useMemo, useCallback } from "react";
import { ListType, TableData, FormType } from "../types";
import { useFormTypes } from "./useFormTypes";
import { useRecords } from "./useRecords";

export function useListData(listType: ListType, selectedFormType: string) {
  const { formTypes, refetch: refetchFormTypes } = useFormTypes();
  const { records, refetch: refetchRecords } = useRecords(
    selectedFormType || null,
    formTypes
  );

  const data = useMemo(() => {
    if (listType === "formTypes") {
      return formTypes.map((type: FormType) => ({
        $id: type.$id,
        name: type.name,
        schema: type.schema,
        data: null,
      })) as TableData[];
    }
    return records;
  }, [listType, formTypes, records]);

  const refetch = useCallback(() => {
    if (listType === "formTypes") {
      refetchFormTypes();
    } else {
      refetchRecords();
    }
  }, [listType, refetchFormTypes, refetchRecords]);

  return { data, formTypes, refetch };
}


==================================================

FILE: src\components\listViewer\hooks\useRecords.ts
----------------------------------------
import { useState, useEffect, useCallback } from "react";
import { TableData, FormType, RecordData } from "../types";
import { getRecordsByFormType } from "@/lib/appwrite";

export function useRecords(formTypeId: string | null, formTypes: FormType[]) {
  const [records, setRecords] = useState<TableData[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchRecords = useCallback(
    async (id: string) => {
      if (!id) {
        setRecords([]);
        return;
      }

      try {
        setLoading(true);
        // REPLACED: fetch -> getRecordsByFormType
        const fetchedRecords = await getRecordsByFormType(id);

        const formType = formTypes.find((t) => t.$id === id);

        if (formType) {
          const processedData = fetchedRecords.map((record) => ({
            $id: record.$id,
            data: record.data as RecordData | null,
            schema: formType.schema,
          }));
          setRecords(processedData);
          setError(null);
        }
      } catch (err) {
        setError("Failed to fetch records");
        console.error("Error fetching records:", err);
        setRecords([]);
      } finally {
        setLoading(false);
      }
    },
    [formTypes]
  );

  useEffect(() => {
    fetchRecords(formTypeId ?? "");
  }, [formTypeId, fetchRecords]);

  const refetch = useCallback(
    () => fetchRecords(formTypeId ?? ""),
    [formTypeId, fetchRecords]
  );

  return { records, loading, error, refetch };
}


==================================================

FILE: src\components\listViewer\hooks\userecordstest.ts
----------------------------------------
// src/components/listViewer/hooks/useRecords.ts
import { useState, useEffect, useCallback } from "react";
import { TableData, FormType, RecordData } from "../types";
import { getRecordsByFormType } from "@/lib/appwrite";

export function useRecords(formTypeId: string | null, formTypes: FormType[]) {
  const [records, setRecords] = useState<TableData[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchRecords = useCallback(
    async (id: string) => {
      if (!id) {
        setRecords([]);
        return;
      }

      try {
        setLoading(true);
        const fetchedRecords = await getRecordsByFormType(id);
        const formType = formTypes.find((t) => t.$id === id);
        if (formType) {
          const processedData = fetchedRecords.map((record) => ({
            $id: record.$id,
            data: record.data as RecordData | null,
            schema: formType.schema,
          }));
          setRecords(processedData);
          setError(null);
        }
      } catch (err) {
        setError("Failed to fetch records");
        console.error("Error fetching records:", err);
        setRecords([]);
      } finally {
        setLoading(false);
      }
    },
    [formTypes]
  );

  useEffect(() => {
    fetchRecords(formTypeId ?? "");
  }, [formTypeId, fetchRecords]);

  const refetch = useCallback(
    () => fetchRecords(formTypeId ?? ""),
    [formTypeId, fetchRecords]
  );

  return { records, loading, error, refetch };
}


==================================================

FILE: src\components\listViewer\hooks\useSnackbar.ts
----------------------------------------
// src/components/listViewer/hooks/useSnackbar.ts
// Copied/adapted from form builder for consistency
import { useState } from "react";
import { AlertColor } from "@mui/material";
import type { SnackbarState } from "../types";

export function useSnackbar(
  initialState: SnackbarState = {
    open: false,
    message: "",
    severity: "success",
  }
) {
  const [snackbar, setSnackbar] = useState<SnackbarState>(initialState);

  const show = (message: string, severity: AlertColor = "success") => {
    setSnackbar({ open: true, message, severity });
  };

  const close = () => {
    setSnackbar((prev) => ({ ...prev, open: false }));
  };

  return { snackbar, show, close };
}


==================================================

FILE: src\components\listViewer\ListViewer.tsx
----------------------------------------
import  { useState, useEffect } from "react";
import { Box, Typography, Button, CircularProgress } from "@mui/material";
import ListTable from "./components/ListTable";
import { ListSelector } from "./components/ListSelector";
import { useListData } from "./hooks/useListData";
import { useColumnGenerator } from "./components/ColumnGenerator";
import { getFormTypes } from "@/lib/appwrite"; // Changed Import
import type { FormType } from "@/types";
import type { AlertColor } from "@mui/material";

interface ListViewerProps {
  onCancel: () => void;
  showSnackbar: (message: string, severity?: AlertColor) => void;
  onRefetch?: () => void;
}

export default function ListViewer({
  onCancel,
  showSnackbar,
  onRefetch,
}: ListViewerProps) {
  const [listType, setListType] = useState<"formTypes" | "records">(
    "formTypes"
  );
  const [selectedFormType, setSelectedFormType] = useState<string>("");
  const [formTypes, setFormTypes] = useState<FormType[]>([]);
  const [loadingTypes, setLoadingTypes] = useState(true);

  const { data, refetch: listRefetch } = useListData(
    listType,
    selectedFormType
  );
  const columns = useColumnGenerator(listType, data);

  useEffect(() => {
    const fetchTypes = async () => {
      setLoadingTypes(true);
      try {
        // REPLACED: fetch -> getFormTypes
        const types = await getFormTypes();
        setFormTypes(types as FormType[]);
      } catch {
        showSnackbar("خطا در بارگذاری انواع فرم", "error");
      } finally {
        setLoadingTypes(false);
      }
    };
    fetchTypes();
  }, [showSnackbar]);

  const handleRefetch = () => {
    listRefetch();
    onRefetch?.();
  };

  const noDataMessage = !data.length
    ? listType === "formTypes" || selectedFormType
      ? "بدون داده"
      : "برای مشاهده لیست، گزینه‌ها را انتخاب کنید."
    : "";

  return (
    <Box sx={{ p: 2 }}>
      {loadingTypes ? (
        <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
          <CircularProgress />
        </Box>
      ) : (
        <ListSelector
          listType={listType}
          onListTypeChange={setListType}
          selectedFormType={selectedFormType}
          onFormTypeChange={setSelectedFormType}
          formTypes={formTypes}
        />
      )}

      {data.length > 0 ? (
        <ListTable
          data={data}
          columns={columns}
          type={listType}
          onRefetch={handleRefetch}
          onSuccess={(msg) => showSnackbar(msg, "success")}
          onError={(msg) => showSnackbar(msg, "error")}
        />
      ) : (
        <Typography variant="body1" sx={{ mt: 2, textAlign: "center" }}>
          {noDataMessage}
        </Typography>
      )}

      <Button onClick={onCancel} sx={{ mt: 2 }}>
        بازگشت
      </Button>
    </Box>
  );
}


==================================================

FILE: src\components\listViewer\types\index.ts
----------------------------------------
// src/components/listViewer/types/index.ts
import { GridColDef } from "@mui/x-data-grid";
import { AlertColor } from "@mui/material";
import type { FieldType, Field, FormSchema, Schema, FormType } from "@/types";

export { FieldType, Field, FormSchema, Schema, FormType };

export interface RecordData {
  header: Record<string, unknown>;
  items: Array<Record<string, unknown>>;
}

export interface TableData {
  $id: string;
  name?: string;
  data?: RecordData | null;
  schema?: FormSchema | Schema;
}

export type ListType = "formTypes" | "records";

export interface ListTableProps<T extends BaseRowData = TableData> {
  data: T[];
  columns: GridColDef[];
  type: ListType;
  onEditSave?: (id: string, data: object) => void;
}

export interface BaseRowData {
  $id: string;
  name?: string;
  data?: object | null;
  schema?: object;
}

export interface EditFormProps<T extends BaseRowData = BaseRowData> {
  row: T;
  type: ListType;
  onSave: (id: string, data: object) => Promise<void>;
  onCancel: () => void;
  onDelete: (id: string) => Promise<void>;
}

export interface ListViewerProps {
  onCancel: () => void;
}

export interface SnackbarState {
  open: boolean;
  message: string;
  severity: AlertColor;
}

export interface ListSelectorProps {
  listType: ListType;
  onListTypeChange: (type: ListType) => void;
  selectedFormType: string;
  onFormTypeChange: (id: string) => void;
  formTypes: FormType[];
}


==================================================

FILE: src\components\listViewer\utils\deleteEntity.ts
----------------------------------------
import { deleteFormType, deleteRecord } from "@/lib/appwrite";

export async function deleteEntity(id: string, type: string) {
  const result =
    type === "formTypes" ? await deleteFormType(id) : await deleteRecord(id);
  return result;
}


==================================================

FILE: src\components\listViewer\utils\formHandlers.ts
----------------------------------------
// utils/formHandlers.ts
import type { FormSchema } from "@/types";
import type { AlertColor } from "@mui/material";
export const handleNewFormType = async (
  schema: FormSchema,
  showSnackbar: (message: string, severity?: AlertColor) => void,
  setActiveSection: (
    section: "formTypes" | "createRecord" | "list" | null
  ) => void
): Promise<void> => {
  // Now calls API internally in component, but keep for compatibility
  if (schema.name) {
    const res = await fetch("/api/form-types", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name: schema.name, schema }),
    });
    if (res.ok) {
      showSnackbar("نوع فرم با موفقیت ذخیره شد!");
      setActiveSection(null);
    } else {
      showSnackbar("خطا در ذخیره نوع فرم", "error");
    }
  } else {
    showSnackbar("نام فرم الزامی است!", "error");
  }
};


==================================================

FILE: src\components\listViewer\utils\getEntityDeleteMessage.ts
----------------------------------------
// src/components/listViewer/utils/getEntityDeleteMessage.ts
export function getEntityDeleteMessage(type: string): string {
  return type === "formTypes" ? "حذف نوع فرم؟" : "حذف رکورد؟";
}


==================================================

FILE: src\components\listViewer\utils\updateEntity.ts
----------------------------------------
import { updateFormType, updateRecord } from "@/lib/appwrite";
import type { FormSchema } from "../types";

export async function updateEntity(
  id: string,
  updatedData: object,
  type: string
) {
  let result;
  if (type === "formTypes") {
    const schema = updatedData as FormSchema;
    result = await updateFormType(id, schema.name, schema);
  } else {
    result = await updateRecord(id, updatedData);
  }
  return result;
}


==================================================

FILE: src\components\NotificationSnackbar.tsx
----------------------------------------
import React from "react";
import { Snackbar, Alert } from "@mui/material";
import type { AlertColor } from "@mui/material"; // Fixed import

interface NotificationSnackbarProps {
  open: boolean;
  message: string;
  severity: AlertColor;
  onClose: () => void;
}

const NotificationSnackbar: React.FC<NotificationSnackbarProps> = ({
  open,
  message,
  severity,
  onClose,
}) => {
  return (
    <Snackbar
      open={open}
      autoHideDuration={6000}
      onClose={onClose}
      anchorOrigin={{ vertical: "bottom", horizontal: "left" }}
      sx={{
        "& .MuiSnackbarContent-root": {
          borderRadius: 12,
          boxShadow: "0 8px 32px rgba(0, 0, 0, 0.24)",
        },
      }}
    >
      <Alert
        onClose={onClose}
        severity={severity}
        variant="filled"
        sx={{
          width: "100%",
          direction: "rtl",
          color: "white",
          fontWeight: 600,
          alignItems: "center",
          px: 2,
          "& .MuiAlert-icon": {
            alignSelf: "center",
            mr: 2,
          },
          "& .MuiAlert-message": {
            ml: 0.5,
            py: 0.75,
            flex: 1,
            fontSize: "1.1rem",
          },
          ...(severity === "success" && { bgcolor: "#2e7d32" }),
          ...(severity === "error" && { bgcolor: "#c62828" }),
          ...(severity === "warning" && { bgcolor: "#ef6c00" }),
          ...(severity === "info" && { bgcolor: "#1565c0" }),
        }}
      >
        {message}
      </Alert>
    </Snackbar>
  );
};

export default NotificationSnackbar;


==================================================

FILE: src\components\ThemeProviders.tsx
----------------------------------------
import React from "react";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import { CacheProvider } from "@emotion/react";
import createCache from "@emotion/cache";
import { prefixer } from "stylis";
import rtlPlugin from "stylis-plugin-rtl";
import CssBaseline from "@mui/material/CssBaseline";

const theme = createTheme({
  direction: "rtl",
  palette: {
    mode: "dark",
    background: {
      default: "#000000",
      paper: "#000000",
    },
    text: {
      primary: "#FFFFFF",
      secondary: "#FFFFFF",
    },
    primary: {
      main: "#FFC400",
    },
    divider: "rgba(255, 255, 255, 0.12)",
  },
  typography: {
    fontFamily: "FarNazanin, sans-serif",
    fontSize: 16,
  },
});

const cacheRtl = createCache({
  key: "muirtl",
  stylisPlugins: [prefixer, rtlPlugin],
});

interface Props {
  children: React.ReactNode;
}

export default function ThemeProviders({ children }: Props) {
  return (
    <CacheProvider value={cacheRtl}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        {children}
      </ThemeProvider>
    </CacheProvider>
  );
}


==================================================

FILE: src\hooks\useSnackbar.ts
----------------------------------------
import { useState, useCallback } from "react";
import type { AlertColor } from "@mui/material"; // Fixed import
import type { SnackbarState } from "../types";

export const useSnackbar = () => {
  const [snackbar, setSnackbar] = useState<SnackbarState>({
    open: false,
    message: "",
    severity: "success",
  });

  const showSnackbar = useCallback(
    (message: string, severity: AlertColor = "success") => {
      setSnackbar({ open: true, message, severity });
    },
    []
  );

  const handleCloseSnackbar = useCallback(() => {
    setSnackbar((prev) => ({ ...prev, open: false }));
  }, []);

  return {
    snackbar,
    showSnackbar,
    handleCloseSnackbar,
    show: showSnackbar,
    close: handleCloseSnackbar,
  };
};


==================================================

FILE: src\index.css
----------------------------------------
/* src/index.css */

:root {
  --background: #000000;
  --foreground: #ededed;
  color-scheme: dark;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  background-color: #000000 !important; /* Force Black */
  min-height: 100vh;
  margin: 0;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: "FarNazanin", Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-tap-highlight-color: transparent;
}

* {
  box-sizing: border-box;
}

a {
  color: inherit;
  text-decoration: none;
}

@font-face {
  font-family: "FarNazanin";
  src: url("./Far_Nazanin.ttf") format("truetype");
  font-weight: normal;
  font-style: normal;
}

.dnd-item {
  outline: none;
}

/* Section Spacing */
.main-section {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  padding-bottom: 80px; /* Space for footer */
}

@media (max-width: 600px) {
  .main-section {
    padding: 1rem 0; /* No side padding on mobile to allow full width */
    width: 100%;
  }
}

/* --- SCROLLBAR LOGIC --- */

/* Desktop: Styled Dark Scrollbar */
@media (min-width: 601px) {
  * {
    scrollbar-width: thin;
    scrollbar-color: #333333 #000000;
  }
  ::-webkit-scrollbar {
    width: 12px;
  }
  ::-webkit-scrollbar-track {
    background: #000000;
  }
  ::-webkit-scrollbar-thumb {
    background-color: #333333;
    border-radius: 20px;
    border: 3px solid #000000;
  }
}

/* Mobile: COMPLETELY HIDDEN Scrollbar */
@media (max-width: 600px) {
  html,
  body,
  * {
    scrollbar-width: none !important; /* Firefox */
    -ms-overflow-style: none !important; /* IE/Edge */
  }

  ::-webkit-scrollbar {
    display: none !important; /* Chrome/Safari */
    width: 0px !important;
    height: 0px !important;
    background: transparent !important;
  }
}
.MuiSelect-select {
  text-align: right !important;
  padding-right: 14px !important;
  padding-left: 32px !important; /* Make room for the arrow on the left */
  display: flex !important;
  align-items: center;
  justify-content: flex-start;
  direction: rtl !important;
}

/* Move the dropdown arrow icon to the left side */
.MuiSelect-icon {
  right: auto !important;
  left: 7px !important;
}

/* Align the Floating Label to the right */
.MuiInputLabel-root {
  left: auto !important;
  right: 1.75rem !important; /* Align with text start */
  transform-origin: top right !important;
}

/* When label shrinks (active), keep it on the right */
.MuiInputLabel-shrink {
  transform: translate(0, -1.5px) scale(0.75) !important;
  right: 14px !important; /* Position when floating */
}

/* Fix the Dropdown Menu Items alignment */
.MuiMenuItem-root {
  justify-content: flex-start !important; /* Align text right */
  text-align: right !important;
  direction: rtl !important;
}

/* Fix Form Control Label (Checkboxes/Radio) alignment */
.MuiFormControlLabel-root {
  direction: rtl;
  margin-right: 0 !important;
  margin-left: 16px !important;
}


==================================================

FILE: src\lib\agent.ts
----------------------------------------
import { getUserId } from "../utils/userId";

const FUNCTION_URL = import.meta.env.VITE_APPWRITE_FUNCTION_AGENT_URL;

export async function agent(userInput: string) {
  const userId = getUserId();

  if (!userInput?.trim()) {
    throw new Error("Missing userInput");
  }

  if (!FUNCTION_URL) {
    console.error("Agent Function URL is missing in .env");
    return {
      text_answer: "خطای تنظیمات: آدرس هوش مصنوعی یافت نشد.",
      success: false,
    };
  }

  try {
    const payload = {
      userInput,
      userId: userId || "",
    };

    // Call the Appwrite Function directly via HTTP
    const response = await fetch(FUNCTION_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-user-id": userId || "",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error("Function responded with error:", response.status);
      throw new Error(`Function call failed: ${response.status}`);
    }

    // Parse response
    // Appwrite functions usually return JSON, but sometimes plain text if misconfigured
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
      const result = await response.json();
      return result;
    } else {
      const text = await response.text();
      return { text_answer: text, success: true };
    }
  } catch (error: unknown) {
    console.error("Agent client error:", error);
    const errorMsg = error instanceof Error ? error.message : "Unknown error";

    return {
      text_answer: "خطا در پردازش. لطفاً دوباره تلاش کنید.",
      success: false,
      error: errorMsg,
    };
  }
}


==================================================

FILE: src\lib\appwrite.ts
----------------------------------------
import { Client, Account, Databases, ID, Query } from "appwrite";
// Fix 1: Import Models as a type explicitly
import type { Models } from "appwrite";
import { getUserId } from "../utils/userId";

// 1. Initialize Client (Client-Side)
const client = new Client()
  .setEndpoint(import.meta.env.VITE_APPWRITE_ENDPOINT)
  .setProject(import.meta.env.VITE_APPWRITE_PROJECT_ID);

export const account = new Account(client);
export const databases = new Databases(client);

// 2. Constants
export const DATABASE_ID = import.meta.env.VITE_APPWRITE_DATABASE_ID;
export const FORM_TYPES_COLLECTION = import.meta.env.VITE_COLLECTION_FORM_TYPES;
export const RECORDS_COLLECTION = import.meta.env.VITE_COLLECTION_RECORDS;
export const CHAT_COLLECTION = import.meta.env.VITE_COLLECTION_CHAT;

export const generateId = () => ID.unique();

// 3. Interfaces
export interface FormTypeDoc extends Models.Document {
  name: string;
  form_types: string;
  userId: string;
}

export interface RecordDoc extends Models.Document {
  formTypeId: string;
  data: string;
  userId: string;
}

export interface ChatDocument extends Models.Document {
  role: "user" | "assistant";
  messages: string[];
  userId: string;
}

// --- FORM TYPES LOGIC ---

export async function getFormTypes() {
  const userId = getUserId();
  try {
    const response = await databases.listDocuments(
      DATABASE_ID,
      FORM_TYPES_COLLECTION,
      [Query.equal("userId", userId)]
    );

    return response.documents.map((doc) => {
      // Fix 2: Double cast (doc -> unknown -> FormTypeDoc) to satisfy TypeScript
      const typedDoc = doc as unknown as FormTypeDoc;
      let parsedSchema = {};
      try {
        parsedSchema = JSON.parse(typedDoc.form_types);
      } catch (e) {
        console.error("Schema parse error", e);
      }
      return {
        $id: typedDoc.$id,
        name: typedDoc.name,
        schema: parsedSchema,
      };
    });
  } catch (error) {
    console.error("Get Form Types Error:", error);
    return [];
  }
}

export async function createFormType(name: string, schema: object) {
  const userId = getUserId();
  try {
    const response = await databases.createDocument(
      DATABASE_ID,
      FORM_TYPES_COLLECTION,
      ID.unique(),
      {
        name,
        form_types: JSON.stringify(schema),
        userId,
      }
    );
    return { $id: response.$id, success: true };
  } catch (error) {
    console.error("Create Form Type Error:", error);
    return { success: false, error };
  }
}

export async function updateFormType(id: string, name: string, schema: object) {
  const userId = getUserId();
  try {
    await databases.updateDocument(DATABASE_ID, FORM_TYPES_COLLECTION, id, {
      name,
      form_types: JSON.stringify(schema),
      userId,
    });
    return { success: true };
  } catch (error) {
    console.error("Update Form Type Error:", error);
    return { success: false, error };
  }
}

export async function deleteFormType(id: string) {
  try {
    await databases.deleteDocument(DATABASE_ID, FORM_TYPES_COLLECTION, id);
    return { success: true };
  } catch (error) {
    console.error("Delete Form Type Error:", error);
    return { success: false, error };
  }
}

// --- RECORDS LOGIC ---

export async function getRecordsByFormType(formTypeId: string) {
  const userId = getUserId();
  if (!formTypeId) return [];

  try {
    const response = await databases.listDocuments(
      DATABASE_ID,
      RECORDS_COLLECTION,
      [Query.equal("formTypeId", formTypeId), Query.equal("userId", userId)]
    );

    return response.documents.map((doc) => {
      // Fix 2: Double cast here as well
      const typedDoc = doc as unknown as RecordDoc;
      let parsedData = null;
      try {
        parsedData = JSON.parse(typedDoc.data);
      } catch (e) {
        console.error("Data parse error", e);
      }
      return {
        $id: typedDoc.$id,
        formTypeId: typedDoc.formTypeId,
        data: parsedData,
      };
    });
  } catch (error) {
    console.error("Get Records Error:", error);
    return [];
  }
}

export async function createRecord(formTypeId: string, data: object) {
  const userId = getUserId();
  try {
    const response = await databases.createDocument(
      DATABASE_ID,
      RECORDS_COLLECTION,
      ID.unique(),
      {
        formTypeId,
        data: JSON.stringify(data),
        userId,
      }
    );
    return { $id: response.$id, success: true };
  } catch (error) {
    console.error("Create Record Error:", error);
    return { success: false, error };
  }
}

export async function updateRecord(id: string, data: object) {
  try {
    await databases.updateDocument(DATABASE_ID, RECORDS_COLLECTION, id, {
      data: JSON.stringify(data),
    });
    return { success: true };
  } catch (error) {
    console.error("Update Record Error:", error);
    return { success: false, error };
  }
}

export async function deleteRecord(id: string) {
  try {
    await databases.deleteDocument(DATABASE_ID, RECORDS_COLLECTION, id);
    return { success: true };
  } catch (error) {
    console.error("Delete Record Error:", error);
    return { success: false, error };
  }
}

export async function getRecordsForReference(targetFormTypeId: string) {
  return await getRecordsByFormType(targetFormTypeId);
}

// --- CHAT LOGIC ---

export async function getChatMessages() {
  const userId = getUserId();
  try {
    const response = await databases.listDocuments(
      DATABASE_ID,
      CHAT_COLLECTION,
      [Query.orderAsc("$createdAt"), Query.equal("userId", userId)]
    );

    // Fix 2: Double cast for ChatDocument
    const docs = response.documents as unknown as ChatDocument[];
    return docs.flatMap((doc) =>
      doc.messages.map((msg) => ({ role: doc.role, text: msg }))
    );
  } catch (error) {
    console.error("Chat fetch error:", error);
    return [];
  }
}

export async function saveChatMessage(
  role: "user" | "assistant",
  message: string
) {
  const userId = getUserId();
  try {
    await databases.createDocument(DATABASE_ID, CHAT_COLLECTION, ID.unique(), {
      role,
      messages: [message],
      userId,
    });
    return { success: true };
  } catch (error) {
    console.error("Chat save error:", error);
    return { success: false, error };
  }
}


==================================================

FILE: src\main.tsx
----------------------------------------
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


==================================================

FILE: src\pages\About.tsx
----------------------------------------
import { Box, Typography, Container } from "@mui/material";

export default function AboutPage() {
  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "80vh",
          textAlign: "center",
          gap: 3,
          color: "white",
        }}
      >
        <Typography
          variant="h4"
          sx={{ fontWeight: "bold", color: "#FFC400", mt: 2 }}
        >
          درباره ما
        </Typography>

        <Typography variant="body1" sx={{ lineHeight: 2, fontSize: "1.1rem" }}>
          این پروژه با هدف ساده‌سازی فرآیند ساخت فرم‌های پیچیده و مدیریت داده‌ها
          طراحی شده است.
          <br />
          با استفاده از هوش مصنوعی، شما می‌توانید ساختارهای داده‌ای خود را تنها
          با گفتگو ایجاد کنید.
        </Typography>

        <Typography variant="body2" sx={{ color: "grey.500", mt: 4 }}>
          نسخه ۱.۰.۰
        </Typography>
      </Box>
    </Container>
  );
}


==================================================

FILE: src\pages\Home.tsx
----------------------------------------
import { useState, useCallback } from "react";
import { Box, Fade } from "@mui/material";
import FormTypeManager from "@/components/formBuilder/FormTypeManager";
import CreateRecord from "@/components/dynamicForm/CreateRecord";
import ListViewer from "@/components/listViewer/ListViewer";
import AnimatedEye from "@/components/animatedEye/AnimatedEye";
import ActionButtons from "@/components/ActionButtons";
import NotificationSnackbar from "@/components/NotificationSnackbar";
import { handleNewFormType } from "@/utils/formHandlers";
import { useSnackbar } from "@/hooks/useSnackbar";
import type { FormSchema } from "@/types";

export default function Home() {
  const [activeSection, setActiveSection] = useState<
    "formTypes" | "createRecord" | "list" | null
  >(null);

  // Angry Mode State
  const [isEyeAngry, setIsEyeAngry] = useState(false);

  const { snackbar, showSnackbar, handleCloseSnackbar } = useSnackbar();
  const [refreshKey, setRefreshKey] = useState(0);

  const triggerRefetch = useCallback(() => {
    setActiveSection(null);
    setRefreshKey((prev) => prev + 1);
  }, []);

  const handleRecordSuccess = useCallback(() => {
    setActiveSection(null);
    triggerRefetch();
  }, [triggerRefetch]);

  const handleFormTypeSave = useCallback(
    async (schema: FormSchema) => {
      await handleNewFormType(schema, showSnackbar, setActiveSection);
      triggerRefetch();
    },
    [showSnackbar, triggerRefetch]
  );

  const toggleSection = useCallback(
    (section: "formTypes" | "createRecord" | "list") => {
      setActiveSection((prev) => (prev === section ? null : section));
    },
    []
  );

  const handleChatRefresh = useCallback(() => {
    triggerRefetch();
  }, [triggerRefetch]);

  return (
    <Box className="main-section">
      <AnimatedEye
        showSnackbar={showSnackbar}
        onChatRefresh={handleChatRefresh}
        onAngryStateChange={setIsEyeAngry}
      />

      {/* Hide Buttons when Angry */}
      <Fade in={!isEyeAngry} timeout={500}>
        <Box>
          <ActionButtons
            onFormTypes={() => toggleSection("formTypes")}
            onCreateRecord={() => toggleSection("createRecord")}
            onList={() => toggleSection("list")}
          />
        </Box>
      </Fade>

      {activeSection === "formTypes" && (
        <FormTypeManager
          key={`form-types-${refreshKey}`}
          onNewSave={handleFormTypeSave}
          onCancel={() => setActiveSection(null)}
        />
      )}

      {activeSection === "createRecord" && (
        <CreateRecord
          key={`create-record-${refreshKey}`}
          onSuccess={handleRecordSuccess}
          onCancel={() => setActiveSection(null)}
          showSnackbar={showSnackbar}
        />
      )}

      {activeSection === "list" && (
        <ListViewer
          key={`list-${refreshKey}`}
          onCancel={() => setActiveSection(null)}
          showSnackbar={showSnackbar}
          onRefetch={triggerRefetch}
        />
      )}

      <NotificationSnackbar
        open={snackbar.open}
        message={snackbar.message}
        severity={snackbar.severity}
        onClose={handleCloseSnackbar}
      />
    </Box>
  );
}


==================================================

FILE: src\types\index.ts
----------------------------------------
import type { AlertColor } from "@mui/material"; // Fixed import

export type FieldType =
  | "text"
  | "textarea"
  | "number"
  | "integer"
  | "decimal"
  | "email"
  | "password"
  | "url"
  | "date"
  | "datetime"
  | "time"
  | "select"
  | "multiselect"
  | "checkbox"
  | "radio"
  | "file"
  | "image"
  | "hidden"
  | "reference"
  | "boolean";

export interface Field {
  id: string;
  type: FieldType;
  label: string;
  required?: boolean;
  options?: string[];
  targetFormType?: string;
  displayField?: string;
  multiple?: boolean;
}

export interface FormSchema {
  name: string;
  hasItems: boolean;
  headerFields: Field[];
  itemFields: Field[];
}

export interface Schema {
  hasItems: boolean;
  headerFields: Field[];
  itemFields: Field[];
}

export interface FormType {
  $id: string;
  name: string;
  schema: FormSchema;
}

export const FIELD_TYPES: { [key in FieldType]: string } = {
  text: "فیلد متنی",
  textarea: "فیلد متنی چندخطی",
  number: "فیلد عددی",
  integer: "عدد صحیح",
  decimal: "عدد اعشاری",
  email: "ایمیل",
  password: "رمز عبور",
  url: "آدرس وب",
  date: "تاریخ",
  datetime: "تاریخ و زمان",
  time: "زمان",
  select: "لیست کشویی",
  multiselect: "چند انتخابی",
  checkbox: "چک‌باکس",
  radio: "دکمه رادیویی",
  file: "فایل",
  image: "تصویر",
  hidden: "مخفی",
  reference: "مرجع موجودیت",
  boolean: "بولی",
};

export const TYPE_TO_PERSIAN: { [key in FieldType]: string } = {
  text: "متنی",
  textarea: "متنی چندخطی",
  number: "عددی",
  integer: "عدد صحیح",
  decimal: "اعشاری",
  email: "ایمیل",
  password: "رمز",
  url: "وب",
  date: "تاریخ",
  datetime: "تاریخ/زمان",
  time: "زمان",
  select: "انتخابی",
  multiselect: "چندانتخابی",
  checkbox: "چک‌باکس",
  radio: "رادیویی",
  file: "فایل",
  image: "تصویر",
  hidden: "مخفی",
  reference: "مرجع",
  boolean: "بولی",
};

export interface SnackbarState {
  open: boolean;
  message: string;
  severity: AlertColor;
}


==================================================

FILE: src\utils\formHandlers.ts
----------------------------------------
import { createFormType } from "@/lib/appwrite";
import { AlertColor } from "@mui/material";
import type { FormSchema } from "@/types";

export const handleNewFormType = async (
  schema: FormSchema,
  showSnackbar: (message: string, severity?: AlertColor) => void,
  setActiveSection: (
    section: "formTypes" | "createRecord" | "list" | null
  ) => void
): Promise<void> => {
  // Logic updated to use createFormType directly instead of fetch
  if (schema.name) {
    const result = await createFormType(schema.name, schema);
    if (result.success && result.$id) {
      showSnackbar("نوع فرم با موفقیت ذخیره شد!");
      setActiveSection(null);
    } else {
      showSnackbar("خطا در ذخیره نوع فرم", "error");
    }
  } else {
    showSnackbar("نام فرم الزامی است!", "error");
  }
};


==================================================

FILE: src\utils\userId.ts
----------------------------------------
import { v4 as uuidv4 } from "uuid";

export function getUserId(): string {
  let userId = localStorage.getItem("formBuilderUserId");

  if (!userId) {
    userId = uuidv4();
    localStorage.setItem("formBuilderUserId", userId);
    console.log("New User ID created:", userId);
  }

  return userId;
}

// We don't need getAuthHeaders anymore because we aren't using fetch() to our own API.
// But we can keep a helper if we need to pass ID to other services.
export function getAuthHeaders() {
  return {
    "Content-Type": "application/json",
    "x-user-id": getUserId(),
  };
}

export function clearUserId(): void {
  localStorage.removeItem("formBuilderUserId");
}


==================================================

FILE: tsconfig.app.json
----------------------------------------
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


==================================================

FILE: tsconfig.json
----------------------------------------
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting - Relaxed for build */
    "strict": true,
    "noUnusedLocals": false, // <--- CHANGED TO FALSE
    "noUnusedParameters": false, // <--- CHANGED TO FALSE
    "noFallthroughCasesInSwitch": true,

    /* Path Alias Configuration */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Fix for import.meta.env */
    "types": ["vite/client", "node"]
  },
  "include": ["src"]
}


==================================================

FILE: tsconfig.node.json
----------------------------------------
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


==================================================

FILE: vite.config.ts
----------------------------------------
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  base: "/mother-of-all-forms/",
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});


==================================================

